<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>protkit.metrics.sequence_eval API documentation</title>
<meta name="description" content="Implements class `SequenceEval` for evaluating protein sequences …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>protkit.metrics.sequence_eval</code></h1>
</header>
<section id="section-intro">
<p>Implements class <code><a title="protkit.metrics.sequence_eval.SequenceEval" href="#protkit.metrics.sequence_eval.SequenceEval">SequenceEval</a></code> for evaluating protein sequences.</p>
<p>Various metrics, such as sequence identity, similarity, and coverage, can be calculated
to evaluate the quality of a protein sequence. These scores can be used to compare two
sequences or to evaluate a single sequence against a reference sequence.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding:utf-8 -*-
# Authors:  Fred Senekal (FS)
# Contact:  fred@silicogenesis.com
# License:  GPLv3

&#34;&#34;&#34;
Implements class `SequenceEval` for evaluating protein sequences.

Various metrics, such as sequence identity, similarity, and coverage, can be calculated
to evaluate the quality of a protein sequence. These scores can be used to compare two
sequences or to evaluate a single sequence against a reference sequence.
&#34;&#34;&#34;

from protkit.seq import Sequence
from protkit.metrics.scoring_matrix import ScoringMatrix


class SequenceEval:
    @staticmethod
    def sequence_identity(seq1: Sequence,
                          seq2: Sequence) -&gt; float:
        &#34;&#34;&#34;
        Calculate the sequence identity between two sequences.

        Sequence identity is a measure of the similarity between two sequences. It is
        defined as the number of identical residues divided by the total number of residues.

        Args:
            seq1 (Sequence): The first sequence.
            seq2 (Sequence): The second sequence.

        Returns:
            float: A float representing the sequence identity between the two sequences.

        Raises:
            ValueError: If the sequences are not of equal length.
        &#34;&#34;&#34;
        if seq1.length != seq2.length:
            raise ValueError(&#34;Sequences must be of equal length.&#34;)
        if seq1.length == 0:
            raise ValueError(&#34;Sequences must have a length greater than 0.&#34;)

        identity = 0
        for i in range(seq1.length):
            if seq1[i] == seq2[i]:
                identity += 1

        return identity / seq1.length

    @staticmethod
    def sequence_similarity(seq1: Sequence,
                            seq2: Sequence,
                            match_score: int = 2,
                            mismatch_score: int = -1,
                            scoring_matrix: ScoringMatrix = None) -&gt; float:
        &#34;&#34;&#34;
        Calculate the sequence similarity between two sequences.

        Sequence similarity is a measure of the similarity between two sequences. It is
        defined as the sum of the scores for matching residues divided by the total number
        of residues.

        Args:
            seq1 (str): The first sequence.
            seq2 (str): The second sequence.
            match_score (int): The score to assign to matching residues.
            mismatch_score (int): The score to assign to mismatching residues.
            scoring_matrix (ScoringMatrix): The scoring matrix to use for scoring residue pairs.

        Returns:
            float: A float representing the sequence similarity between the two sequences.

        Raises:
            ValueError: If the sequences are not of equal length.
        &#34;&#34;&#34;
        if seq1.length != seq2.length:
            raise ValueError(&#34;Sequences must be of equal length.&#34;)
        if seq1.length == 0:
            raise ValueError(&#34;Sequences must have a length greater than 0.&#34;)

        similarity = 0
        if scoring_matrix is not None:
            for i in range(seq1.length):
                similarity += scoring_matrix.score(seq1[i], seq2[i])
        else:
            for i in range(seq1.length):
                if seq1[i] == seq2[i]:
                    similarity += match_score
                else:
                    similarity += mismatch_score

        return similarity / seq1.length

    @staticmethod
    def alignment_coverage(seq: Sequence, gap_symbol: str = &#34;-&#34;) -&gt; float:
        &#34;&#34;&#34;
        Calculate the alignment coverage between two sequences.

        Alignment coverage is a measure of the proportion of residues in one sequence that
        are aligned with residues in another sequence. It is defined as the number of aligned
        residues divided by the total number of residues.

        Args:
            seq (Sequence): The sequence.
            gap_symbol (str): The symbol used to represent gaps in the alignment.

        Returns:
            float: A float representing the alignment coverage of the sequence.
        &#34;&#34;&#34;
        if seq.length == 0:
            raise ValueError(&#34;Sequence must have a length greater than 0.&#34;)

        aligned_residues = 0
        for residue in seq:
            if residue != gap_symbol:
                aligned_residues += 1

        return aligned_residues / seq.length

    @staticmethod
    def edit_distance(seq1: Sequence, seq2: Sequence) -&gt; float:
        &#34;&#34;&#34;
        Calculate the edit distance (Levenshtein distance) between two sequences.

        The edit distance is a measure of the similarity between two sequences. It is defined
        as the minimum number of single-character edits (insertions, deletions, or substitutions)
        required to change one sequence into the other.

        Args:
            seq1 (str): The first sequence.
            seq2 (str): The second sequence.

        Returns:
            float: A float representing the edit distance between the two sequences.

        Raises:
            ValueError: If the sequences are not of equal length.
        &#34;&#34;&#34;
        if seq1.length == 0 or seq2.length == 0:
            raise ValueError(&#34;Sequences must have a length greater than 0.&#34;)

        # Initialize the matrix.
        rows = seq1.length + 1
        cols = seq2.length + 1
        matrix = [[0] * cols for _ in range(rows)]

        # Fill the matrix.
        for i in range(rows):
            matrix[i][0] = i
        for j in range(cols):
            matrix[0][j] = j

        for i in range(1, rows):
            for j in range(1, cols):
                if seq1[i - 1] == seq2[j - 1]:
                    cost = 0
                else:
                    cost = 1
                matrix[i][j] = min(matrix[i - 1][j] + 1,    # Deletion
                                   matrix[i][j - 1] + 1,    # Insertion
                                   matrix[i - 1][j - 1] + cost)  # Substitution

        # The edit distance is the value in the bottom-right corner of the matrix.
        edit_distance = matrix[rows - 1][cols - 1]

        return edit_distance</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="protkit.metrics.sequence_eval.SequenceEval"><code class="flex name class">
<span>class <span class="ident">SequenceEval</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SequenceEval:
    @staticmethod
    def sequence_identity(seq1: Sequence,
                          seq2: Sequence) -&gt; float:
        &#34;&#34;&#34;
        Calculate the sequence identity between two sequences.

        Sequence identity is a measure of the similarity between two sequences. It is
        defined as the number of identical residues divided by the total number of residues.

        Args:
            seq1 (Sequence): The first sequence.
            seq2 (Sequence): The second sequence.

        Returns:
            float: A float representing the sequence identity between the two sequences.

        Raises:
            ValueError: If the sequences are not of equal length.
        &#34;&#34;&#34;
        if seq1.length != seq2.length:
            raise ValueError(&#34;Sequences must be of equal length.&#34;)
        if seq1.length == 0:
            raise ValueError(&#34;Sequences must have a length greater than 0.&#34;)

        identity = 0
        for i in range(seq1.length):
            if seq1[i] == seq2[i]:
                identity += 1

        return identity / seq1.length

    @staticmethod
    def sequence_similarity(seq1: Sequence,
                            seq2: Sequence,
                            match_score: int = 2,
                            mismatch_score: int = -1,
                            scoring_matrix: ScoringMatrix = None) -&gt; float:
        &#34;&#34;&#34;
        Calculate the sequence similarity between two sequences.

        Sequence similarity is a measure of the similarity between two sequences. It is
        defined as the sum of the scores for matching residues divided by the total number
        of residues.

        Args:
            seq1 (str): The first sequence.
            seq2 (str): The second sequence.
            match_score (int): The score to assign to matching residues.
            mismatch_score (int): The score to assign to mismatching residues.
            scoring_matrix (ScoringMatrix): The scoring matrix to use for scoring residue pairs.

        Returns:
            float: A float representing the sequence similarity between the two sequences.

        Raises:
            ValueError: If the sequences are not of equal length.
        &#34;&#34;&#34;
        if seq1.length != seq2.length:
            raise ValueError(&#34;Sequences must be of equal length.&#34;)
        if seq1.length == 0:
            raise ValueError(&#34;Sequences must have a length greater than 0.&#34;)

        similarity = 0
        if scoring_matrix is not None:
            for i in range(seq1.length):
                similarity += scoring_matrix.score(seq1[i], seq2[i])
        else:
            for i in range(seq1.length):
                if seq1[i] == seq2[i]:
                    similarity += match_score
                else:
                    similarity += mismatch_score

        return similarity / seq1.length

    @staticmethod
    def alignment_coverage(seq: Sequence, gap_symbol: str = &#34;-&#34;) -&gt; float:
        &#34;&#34;&#34;
        Calculate the alignment coverage between two sequences.

        Alignment coverage is a measure of the proportion of residues in one sequence that
        are aligned with residues in another sequence. It is defined as the number of aligned
        residues divided by the total number of residues.

        Args:
            seq (Sequence): The sequence.
            gap_symbol (str): The symbol used to represent gaps in the alignment.

        Returns:
            float: A float representing the alignment coverage of the sequence.
        &#34;&#34;&#34;
        if seq.length == 0:
            raise ValueError(&#34;Sequence must have a length greater than 0.&#34;)

        aligned_residues = 0
        for residue in seq:
            if residue != gap_symbol:
                aligned_residues += 1

        return aligned_residues / seq.length

    @staticmethod
    def edit_distance(seq1: Sequence, seq2: Sequence) -&gt; float:
        &#34;&#34;&#34;
        Calculate the edit distance (Levenshtein distance) between two sequences.

        The edit distance is a measure of the similarity between two sequences. It is defined
        as the minimum number of single-character edits (insertions, deletions, or substitutions)
        required to change one sequence into the other.

        Args:
            seq1 (str): The first sequence.
            seq2 (str): The second sequence.

        Returns:
            float: A float representing the edit distance between the two sequences.

        Raises:
            ValueError: If the sequences are not of equal length.
        &#34;&#34;&#34;
        if seq1.length == 0 or seq2.length == 0:
            raise ValueError(&#34;Sequences must have a length greater than 0.&#34;)

        # Initialize the matrix.
        rows = seq1.length + 1
        cols = seq2.length + 1
        matrix = [[0] * cols for _ in range(rows)]

        # Fill the matrix.
        for i in range(rows):
            matrix[i][0] = i
        for j in range(cols):
            matrix[0][j] = j

        for i in range(1, rows):
            for j in range(1, cols):
                if seq1[i - 1] == seq2[j - 1]:
                    cost = 0
                else:
                    cost = 1
                matrix[i][j] = min(matrix[i - 1][j] + 1,    # Deletion
                                   matrix[i][j - 1] + 1,    # Insertion
                                   matrix[i - 1][j - 1] + cost)  # Substitution

        # The edit distance is the value in the bottom-right corner of the matrix.
        edit_distance = matrix[rows - 1][cols - 1]

        return edit_distance</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="protkit.metrics.sequence_eval.SequenceEval.alignment_coverage"><code class="name flex">
<span>def <span class="ident">alignment_coverage</span></span>(<span>seq: <a title="protkit.seq.sequence.Sequence" href="../seq/sequence.html#protkit.seq.sequence.Sequence">Sequence</a>, gap_symbol: str = '-') ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the alignment coverage between two sequences.</p>
<p>Alignment coverage is a measure of the proportion of residues in one sequence that
are aligned with residues in another sequence. It is defined as the number of aligned
residues divided by the total number of residues.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>seq</code></strong> :&ensp;<code>Sequence</code></dt>
<dd>The sequence.</dd>
<dt><strong><code>gap_symbol</code></strong> :&ensp;<code>str</code></dt>
<dd>The symbol used to represent gaps in the alignment.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>A float representing the alignment coverage of the sequence.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def alignment_coverage(seq: Sequence, gap_symbol: str = &#34;-&#34;) -&gt; float:
    &#34;&#34;&#34;
    Calculate the alignment coverage between two sequences.

    Alignment coverage is a measure of the proportion of residues in one sequence that
    are aligned with residues in another sequence. It is defined as the number of aligned
    residues divided by the total number of residues.

    Args:
        seq (Sequence): The sequence.
        gap_symbol (str): The symbol used to represent gaps in the alignment.

    Returns:
        float: A float representing the alignment coverage of the sequence.
    &#34;&#34;&#34;
    if seq.length == 0:
        raise ValueError(&#34;Sequence must have a length greater than 0.&#34;)

    aligned_residues = 0
    for residue in seq:
        if residue != gap_symbol:
            aligned_residues += 1

    return aligned_residues / seq.length</code></pre>
</details>
</dd>
<dt id="protkit.metrics.sequence_eval.SequenceEval.edit_distance"><code class="name flex">
<span>def <span class="ident">edit_distance</span></span>(<span>seq1: <a title="protkit.seq.sequence.Sequence" href="../seq/sequence.html#protkit.seq.sequence.Sequence">Sequence</a>, seq2: <a title="protkit.seq.sequence.Sequence" href="../seq/sequence.html#protkit.seq.sequence.Sequence">Sequence</a>) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the edit distance (Levenshtein distance) between two sequences.</p>
<p>The edit distance is a measure of the similarity between two sequences. It is defined
as the minimum number of single-character edits (insertions, deletions, or substitutions)
required to change one sequence into the other.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>seq1</code></strong> :&ensp;<code>str</code></dt>
<dd>The first sequence.</dd>
<dt><strong><code>seq2</code></strong> :&ensp;<code>str</code></dt>
<dd>The second sequence.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>A float representing the edit distance between the two sequences.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the sequences are not of equal length.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def edit_distance(seq1: Sequence, seq2: Sequence) -&gt; float:
    &#34;&#34;&#34;
    Calculate the edit distance (Levenshtein distance) between two sequences.

    The edit distance is a measure of the similarity between two sequences. It is defined
    as the minimum number of single-character edits (insertions, deletions, or substitutions)
    required to change one sequence into the other.

    Args:
        seq1 (str): The first sequence.
        seq2 (str): The second sequence.

    Returns:
        float: A float representing the edit distance between the two sequences.

    Raises:
        ValueError: If the sequences are not of equal length.
    &#34;&#34;&#34;
    if seq1.length == 0 or seq2.length == 0:
        raise ValueError(&#34;Sequences must have a length greater than 0.&#34;)

    # Initialize the matrix.
    rows = seq1.length + 1
    cols = seq2.length + 1
    matrix = [[0] * cols for _ in range(rows)]

    # Fill the matrix.
    for i in range(rows):
        matrix[i][0] = i
    for j in range(cols):
        matrix[0][j] = j

    for i in range(1, rows):
        for j in range(1, cols):
            if seq1[i - 1] == seq2[j - 1]:
                cost = 0
            else:
                cost = 1
            matrix[i][j] = min(matrix[i - 1][j] + 1,    # Deletion
                               matrix[i][j - 1] + 1,    # Insertion
                               matrix[i - 1][j - 1] + cost)  # Substitution

    # The edit distance is the value in the bottom-right corner of the matrix.
    edit_distance = matrix[rows - 1][cols - 1]

    return edit_distance</code></pre>
</details>
</dd>
<dt id="protkit.metrics.sequence_eval.SequenceEval.sequence_identity"><code class="name flex">
<span>def <span class="ident">sequence_identity</span></span>(<span>seq1: <a title="protkit.seq.sequence.Sequence" href="../seq/sequence.html#protkit.seq.sequence.Sequence">Sequence</a>, seq2: <a title="protkit.seq.sequence.Sequence" href="../seq/sequence.html#protkit.seq.sequence.Sequence">Sequence</a>) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the sequence identity between two sequences.</p>
<p>Sequence identity is a measure of the similarity between two sequences. It is
defined as the number of identical residues divided by the total number of residues.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>seq1</code></strong> :&ensp;<code>Sequence</code></dt>
<dd>The first sequence.</dd>
<dt><strong><code>seq2</code></strong> :&ensp;<code>Sequence</code></dt>
<dd>The second sequence.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>A float representing the sequence identity between the two sequences.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the sequences are not of equal length.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sequence_identity(seq1: Sequence,
                      seq2: Sequence) -&gt; float:
    &#34;&#34;&#34;
    Calculate the sequence identity between two sequences.

    Sequence identity is a measure of the similarity between two sequences. It is
    defined as the number of identical residues divided by the total number of residues.

    Args:
        seq1 (Sequence): The first sequence.
        seq2 (Sequence): The second sequence.

    Returns:
        float: A float representing the sequence identity between the two sequences.

    Raises:
        ValueError: If the sequences are not of equal length.
    &#34;&#34;&#34;
    if seq1.length != seq2.length:
        raise ValueError(&#34;Sequences must be of equal length.&#34;)
    if seq1.length == 0:
        raise ValueError(&#34;Sequences must have a length greater than 0.&#34;)

    identity = 0
    for i in range(seq1.length):
        if seq1[i] == seq2[i]:
            identity += 1

    return identity / seq1.length</code></pre>
</details>
</dd>
<dt id="protkit.metrics.sequence_eval.SequenceEval.sequence_similarity"><code class="name flex">
<span>def <span class="ident">sequence_similarity</span></span>(<span>seq1: <a title="protkit.seq.sequence.Sequence" href="../seq/sequence.html#protkit.seq.sequence.Sequence">Sequence</a>, seq2: <a title="protkit.seq.sequence.Sequence" href="../seq/sequence.html#protkit.seq.sequence.Sequence">Sequence</a>, match_score: int = 2, mismatch_score: int = -1, scoring_matrix: <a title="protkit.metrics.scoring_matrix.ScoringMatrix" href="scoring_matrix.html#protkit.metrics.scoring_matrix.ScoringMatrix">ScoringMatrix</a> = None) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the sequence similarity between two sequences.</p>
<p>Sequence similarity is a measure of the similarity between two sequences. It is
defined as the sum of the scores for matching residues divided by the total number
of residues.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>seq1</code></strong> :&ensp;<code>str</code></dt>
<dd>The first sequence.</dd>
<dt><strong><code>seq2</code></strong> :&ensp;<code>str</code></dt>
<dd>The second sequence.</dd>
<dt><strong><code>match_score</code></strong> :&ensp;<code>int</code></dt>
<dd>The score to assign to matching residues.</dd>
<dt><strong><code>mismatch_score</code></strong> :&ensp;<code>int</code></dt>
<dd>The score to assign to mismatching residues.</dd>
<dt><strong><code>scoring_matrix</code></strong> :&ensp;<code>ScoringMatrix</code></dt>
<dd>The scoring matrix to use for scoring residue pairs.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>A float representing the sequence similarity between the two sequences.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the sequences are not of equal length.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sequence_similarity(seq1: Sequence,
                        seq2: Sequence,
                        match_score: int = 2,
                        mismatch_score: int = -1,
                        scoring_matrix: ScoringMatrix = None) -&gt; float:
    &#34;&#34;&#34;
    Calculate the sequence similarity between two sequences.

    Sequence similarity is a measure of the similarity between two sequences. It is
    defined as the sum of the scores for matching residues divided by the total number
    of residues.

    Args:
        seq1 (str): The first sequence.
        seq2 (str): The second sequence.
        match_score (int): The score to assign to matching residues.
        mismatch_score (int): The score to assign to mismatching residues.
        scoring_matrix (ScoringMatrix): The scoring matrix to use for scoring residue pairs.

    Returns:
        float: A float representing the sequence similarity between the two sequences.

    Raises:
        ValueError: If the sequences are not of equal length.
    &#34;&#34;&#34;
    if seq1.length != seq2.length:
        raise ValueError(&#34;Sequences must be of equal length.&#34;)
    if seq1.length == 0:
        raise ValueError(&#34;Sequences must have a length greater than 0.&#34;)

    similarity = 0
    if scoring_matrix is not None:
        for i in range(seq1.length):
            similarity += scoring_matrix.score(seq1[i], seq2[i])
    else:
        for i in range(seq1.length):
            if seq1[i] == seq2[i]:
                similarity += match_score
            else:
                similarity += mismatch_score

    return similarity / seq1.length</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="protkit.metrics" href="index.html">protkit.metrics</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="protkit.metrics.sequence_eval.SequenceEval" href="#protkit.metrics.sequence_eval.SequenceEval">SequenceEval</a></code></h4>
<ul class="">
<li><code><a title="protkit.metrics.sequence_eval.SequenceEval.alignment_coverage" href="#protkit.metrics.sequence_eval.SequenceEval.alignment_coverage">alignment_coverage</a></code></li>
<li><code><a title="protkit.metrics.sequence_eval.SequenceEval.edit_distance" href="#protkit.metrics.sequence_eval.SequenceEval.edit_distance">edit_distance</a></code></li>
<li><code><a title="protkit.metrics.sequence_eval.SequenceEval.sequence_identity" href="#protkit.metrics.sequence_eval.SequenceEval.sequence_identity">sequence_identity</a></code></li>
<li><code><a title="protkit.metrics.sequence_eval.SequenceEval.sequence_similarity" href="#protkit.metrics.sequence_eval.SequenceEval.sequence_similarity">sequence_similarity</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>