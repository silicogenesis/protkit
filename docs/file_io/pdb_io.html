<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>protkit.file_io.pdb_io API documentation</title>
<meta name="description" content="Implements class `PDBIO` to read and write data
from and to PDB files.
PDB files contain protein structural
information â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>protkit.file_io.pdb_io</code></h1>
</header>
<section id="section-intro">
<p>Implements class <code><a title="protkit.file_io.pdb_io.PDBIO" href="#protkit.file_io.pdb_io.PDBIO">PDBIO</a></code> to read and write data
from and to PDB files.
PDB files contain protein structural
information.</p>
<p>The PDB File Format Specification is available at:
<a href="https://www.wwpdb.org/documentation/file-format-content/format33/v3.3.html">https://www.wwpdb.org/documentation/file-format-content/format33/v3.3.html</a></p>
<p>Currently, PDB records related to structural and sequence data is parsed
and saved.
Other fields are ignored. The following fields are processed:</p>
<ul>
<li>MODEL (model start)</li>
<li>ENDMDL (model end)</li>
<li>ATOM (structural data)</li>
<li>HETATOM (structural data)</li>
<li>SEQRES (sequence data)</li>
<li>TER (chain termination)</li>
<li>MASTER (record keeping)</li>
</ul>
<p>Methods are static and can be called without instantiating the class.
The main functions exposed by the class are:</p>
<ul>
<li><code>load()</code> to load a protein from a PDB file.</li>
<li><code>save()</code> to save a protein to a PDB file.</li>
</ul>
<p><font color="red">Saving a file in PQR format is not supported yet.</font></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding:utf-8 -*-
# Authors:  Fred Senekal (FS)
# Contact:  fred@silicogenesis.com
# License:  GPLv3

&#34;&#34;&#34;
Implements class `PDBIO` to read and write data
from and to PDB files.  PDB files contain protein structural
information.

The PDB File Format Specification is available at:
https://www.wwpdb.org/documentation/file-format-content/format33/v3.3.html

Currently, PDB records related to structural and sequence data is parsed
and saved.  Other fields are ignored. The following fields are processed:

- MODEL (model start)
- ENDMDL (model end)
- ATOM (structural data)
- HETATOM (structural data)
- SEQRES (sequence data)
- TER (chain termination)
- MASTER (record keeping)

Methods are static and can be called without instantiating the class.
The main functions exposed by the class are:

- `load()` to load a protein from a PDB file.
- `save()` to save a protein to a PDB file.

&lt;font color=&#34;red&#34;&gt;Saving a file in PQR format is not supported yet.&lt;/font&gt;

&#34;&#34;&#34;

from typing import List, Dict, Optional
from protkit.structure.protein import Protein
from protkit.structure.chain import Chain
from protkit.structure.residue import Residue
from protkit.structure.atom import Atom


class PDBIO():
    # --------------------------------------------------------------------------------
    # MODEL
    # --------------------------------------------------------------------------------

    @staticmethod
    def parse_pdb_model_line(line: str):
        &#34;&#34;&#34;
        Parse a MODEL (start model) line from a PDB file.

        COLUMNS        DATA  TYPE    FIELD          DEFINITION
        ---------------------------------------------------------------------------------------
         1 -  6        Record name   &#34;MODEL &#34;
        11 - 14        Integer       serial         Model serial number.
        &#34;&#34;&#34;
        pdb_model_dict = {
            &#34;record_name&#34;: &#34;MODEL&#34;,
            &#34;serial&#34;: line[10:14]
        }

        return pdb_model_dict

    @staticmethod
    def create_pdb_model_line(serial: int):
        &#34;&#34;&#34;
        Creates a MODEL (start model) line for a PDB file.
        &#34;&#34;&#34;
        return &#34;MODEL&#34;.ljust(10) + str(serial).rjust(4) + &#34;&#34;.ljust(66)

    # --------------------------------------------------------------------------------
    # ENDMDL
    # --------------------------------------------------------------------------------

    @staticmethod
    def parse_pdb_end_model_line(line: str):
        &#34;&#34;&#34;
        Parse a ENDMDL (end model) line from a PDB file.

        COLUMNS       DATA  TYPE     FIELD        DEFINITION
        ------------------------------------------------------------------
        1 - 6         Record name   &#34;ENDMDL&#34;

        &#34;&#34;&#34;
        pdb_end_model_dict = {
            &#34;record_name&#34;: &#34;ENDMDL&#34;
        }

        return pdb_end_model_dict

    @staticmethod
    def create_pdb_end_model_line():
        &#34;&#34;&#34;
        Creates a ENDMDL (end model) line for a PDB file.
        &#34;&#34;&#34;
        return &#34;ENDMDL&#34;.ljust(80)

    # --------------------------------------------------------------------------------
    # MASTER
    # --------------------------------------------------------------------------------

    @staticmethod
    def create_pdb_master_line(num_atoms, num_hetatoms, num_ter, num_remark=0, num_het=0, num_helix=0, num_sheet=0,
                               num_site=0, num_trans=0, num_conect=0, num_seqres=0):
        &#34;&#34;&#34;
        Creates a MASTER (recordkeeping) line for a PDB file.

        COLUMNS         DATA TYPE     FIELD          DEFINITION
        ----------------------------------------------------------------------------------
         1 -  6         Record name   &#34;MASTER&#34;
        11 - 15         Integer       numRemark      Number of REMARK records
        16 - 20         Integer       &#34;0&#34;
        21 - 25         Integer       numHet         Number of HET records
        26 - 30         Integer       numHelix       Number of HELIX records
        31 - 35         Integer       numSheet       Number of SHEET records
        36 - 40         Integer       numTurn        deprecated
        41 - 45         Integer       numSite        Number of SITE records
        46 - 50         Integer       numXform       Number of coordinate transformation
                                                     records  (ORIGX+SCALE+MTRIX)
        51 - 55         Integer       numCoord       Number of atomic coordinate records
                                                     records (ATOM+HETATM)
        56 - 60         Integer       numTer         Number of TER records
        61 - 65         Integer       numConect      Number of CONECT records
        66 - 70         Integer       numSeq         Number of SEQRES records
        &#34;&#34;&#34;

        entries = [
            &#34;MASTER&#34;.ljust(10),
            str(num_remark).rjust(5),
            &#34;0&#34;.rjust(5),
            str(num_het).rjust(5),
            str(num_helix).rjust(5),
            str(num_sheet).rjust(5),
            &#34;0&#34;.rjust(5),
            str(num_site).rjust(5),
            str(num_trans).rjust(5),
            str(num_atoms + num_hetatoms).rjust(5),
            str(num_ter).rjust(5),
            str(num_conect).rjust(5),
            str(num_seqres).rjust(5),
            &#34;&#34;.ljust(10)
        ]

        return &#34;&#34;.join(entries)

    # --------------------------------------------------------------------------------
    # SEQRES
    # --------------------------------------------------------------------------------

    @staticmethod
    def parse_pdb_seqres_line(line: str):
        &#34;&#34;&#34;
        Parse a SEQRES (sequence) line from a PDB file.
        &#34;&#34;&#34;
        pdb_seqres_dict = {
            &#34;record_name&#34;: &#34;SEQRES&#34;,
            &#34;chain_id&#34;: line[11],
            &#34;residues&#34;: line[19:].strip().split()
        }

        return pdb_seqres_dict

    @staticmethod
    def create_seqres_line(line_no, chain_id, num_residues, residues):
        &#34;&#34;&#34;
        Creates a SEQRES (sequence) line for a PDB file.

         1 -  6        Record name    &#34;SEQRES&#34;
         8 - 10        Integer        serNum       Serial number of the SEQRES record for  the
                                                   current  chain. Starts at 1 and increments
                                                   by one  each line. Reset to 1 for each chain.
        12             Character      chainID      Chain identifier. This may be any single
                                                   legal  character, including a blank which
                                                   is used if there is only one chain.
        14 - 17        Integer        numRes       Number of residues in the chain.
                                                   This  value is repeated on every record.
        20 - 22        Residue name   resName      Residue name.
        24 - 26        Residue name   resName      Residue name.
        28 - 30        Residue name   resName      Residue name.
        32 - 34        Residue name   resName      Residue name.
        36 - 38        Residue name   resName      Residue name.
        40 - 42        Residue name   resName      Residue name.
        44 - 46        Residue name   resName      Residue name.
        48 - 50        Residue name   resName      Residue name.
        52 - 54        Residue name   resName      Residue name.
        56 - 58        Residue name   resName      Residue name.
        60 - 62        Residue name   resName      Residue name.
        64 - 66        Residue name   resName      Residue name.
        68 - 70        Residue name   resName      Residue name.
        &#34;&#34;&#34;
        entries = [
            &#34;SEQRES &#34;,
            str(line_no).rjust(3) + &#34; &#34;,
            chain_id + &#34; &#34;,
            str(num_residues).rjust(4) + &#34;  &#34;
        ]
        for residue in residues:
            entries.append(residue[&#34;residue&#34;].rjust(3) + &#34; &#34;)
        return &#34;&#34;.join(entries).ljust(80)

    # --------------------------------------------------------------------------------
    # TER
    # --------------------------------------------------------------------------------

    @staticmethod
    def parse_pdb_ter_line(line: str):
        &#34;&#34;&#34;
        Parse a TER (chain termination) line from a PDB file.

        COLUMNS        DATA  TYPE    FIELD           DEFINITION
        -------------------------------------------------------------------------
         1 -  6        Record name   &#34;TER   &#34;
         7 - 11        Integer       serial          Serial number.
        18 - 20        Residue name  resName         Residue name.
        22             Character     chainID         Chain identifier.
        23 - 26        Integer       resSeq          Residue sequence number.
        27             AChar         iCode           Insertion code.

        &#34;&#34;&#34;
        if line == &#34;TER&#34;:
            pdb_ter_dict = {
                &#34;record_name&#34;: &#34;TER&#34;,
                &#34;serial&#34;: &#34;&#34;,
                &#34;res_name&#34;: &#34;&#34;,
                &#34;chain_id&#34;: &#34;&#34;,
                &#34;res_seq&#34;: &#34;&#34;,
                &#34;icode&#34;: &#34;&#34;
            }
        else:
            line = line.ljust(80)
            pdb_ter_dict = {
                &#34;record_name&#34;: &#34;TER&#34;,
                &#34;serial&#34;: line[6:11],
                &#34;res_name&#34;: line[17:21],
                &#34;chain_id&#34;: line[21],
                &#34;res_seq&#34;: line[22:26],
                &#34;icode&#34;: line[26]
            }
        return pdb_ter_dict

    @staticmethod
    def create_pdb_ter_line(serial, res_name, chain_id, res_seq, icode):
        &#34;&#34;&#34;
        Creates a TER (chain termination) line for a PDB file.
        &#34;&#34;&#34;
        text = &#34;TER&#34;.ljust(6)
        text += str(serial).rjust(5) + &#34;      &#34;
        text += res_name.rjust(3) + &#34; &#34;
        text += chain_id
        text += res_seq.rjust(4)
        text += icode.ljust(1)

        return text.ljust(80)

    # --------------------------------------------------------------------------------
    # ATOM | HETATM
    # --------------------------------------------------------------------------------

    @staticmethod
    def parse_pdb_atom_line(line, is_pqr_format: bool = False):
        &#34;&#34;&#34;
        Parse a ATOM (individual atom) or HETATM (hetero atom) line from a PDB file.

        COLUMNS        DATA  TYPE    FIELD        DEFINITION
        -------------------------------------------------------------------------------------
         1 -  6        Record name   &#34;ATOM  &#34;
         7 - 11        Integer       serial       Atom  serial number.
        13 - 16        Atom          name         Atom name.
        17             Character     altLoc       Alternate location indicator.
        18 - 20        Residue name  resName      Residue name.
        22             Character     chainID      Chain identifier.
        23 - 26        Integer       resSeq       Residue sequence number.
        27             AChar         iCode        Code for insertion of residues.
        31 - 38        Real(8.3)     x            Orthogonal coordinates for X in Angstroms.
        39 - 46        Real(8.3)     y            Orthogonal coordinates for Y in Angstroms.
        47 - 54        Real(8.3)     z            Orthogonal coordinates for Z in Angstroms.
        55 - 60        Real(6.2)     occupancy    Occupancy.
        61 - 66        Real(6.2)     tempFactor   Temperature  factor.
        77 - 78        LString(2)    element      Element symbol, right-justified.
        79 - 80        LString(2)    charge       Charge  on the atom.`
        &#34;&#34;&#34;
        if not is_pqr_format:
            pdb_atom_dict = {
                &#34;record_name&#34;: line[0:6].strip().upper(),
                &#34;serial&#34;: line[6:11].strip(),
                # Open space
                &#34;atom_name&#34;: line[12:16].strip(),
                &#34;alt_loc&#34;: line[16].strip(),
                &#34;res_name&#34;: line[17:20].strip(),
                # Open space
                &#34;chain_id&#34;: line[21].strip(),
                &#34;res_seq&#34;: line[22:26].strip(),
                &#34;icode&#34;: line[26].strip(),
                # 3x Open space
                &#34;x&#34;: float(line[30:38]),
                &#34;y&#34;: float(line[38:46]),
                &#34;z&#34;: float(line[46:54]),
                &#34;occupancy&#34;: float(line[54:60]),
                # &#34;temp_factor&#34;: None,
                &#34;temp_factor&#34;: float(line[60:66]),
                # 66 - 75?
                &#34;element&#34;: line[76:78].strip(),
                &#34;assigned_charge&#34;: line[78:80].strip(),
                &#34;calculated_charge&#34;: None,
                &#34;radius&#34;: None
            }
        else:
            pdb_atom_dict = {
                &#34;record_name&#34;: line[0:6].strip().upper(),
                &#34;serial&#34;: line[6:11].strip(),
                # Open space
                &#34;atom_name&#34;: line[12:16].strip(),
                &#34;alt_loc&#34;: line[16].strip(),
                &#34;res_name&#34;: line[17:20].strip(),
                # Open space
                &#34;chain_id&#34;: line[21].strip(),
                &#34;res_seq&#34;: line[22:26].strip(),
                &#34;icode&#34;: line[26].strip(),
                # 3x Open space
                &#34;x&#34;: float(line[30:38]),
                &#34;y&#34;: float(line[38:46]),
                &#34;z&#34;: float(line[46:54]),

                &#34;occupancy&#34;: 1.0,
                &#34;temp_factor&#34;: None,

                &#34;element&#34;: line[76:78].strip(),
                &#34;assigned_charge&#34;: None,
                &#34;calculated_charge&#34;: float(line[54:62]),
                &#34;radius&#34;: float(line[62:70])
            }
        return pdb_atom_dict

    @staticmethod
    def create_pdb_atom_line(atom: Dict, serial: int, record_name=&#34;ATOM&#34;) -&gt; str:
        &#34;&#34;&#34;
        Creates a ATOM or HETATM line for a PDB file.

        Args:
            atom (Dict): The atom information.
            serial (int): The serial number of the atom.
            record_name (str): The record name, should be ATOM or HETATM.

        Returns:
            str: The ATOM or HETATM line.
        &#34;&#34;&#34;
        text = record_name.ljust(6)
        text += str(serial).rjust(5) + &#34; &#34;

        # The PDB spec says that if the element has two characters, e.g. Fe (iron)
        # it should start at the position 13, otherwise it should start at position 14.
        # This seems a little problematic, as some atoms could use 4 characters
        # for example, HG11. The implementation here is consistent with observed PDBs
        # from the RCSB.
        if len(atom[&#34;element&#34;]) == 2 or len(atom[&#34;atom_name&#34;]) == 4:
            text += atom[&#34;atom_name&#34;].ljust(4)
        else:
            text += &#34; &#34; + atom[&#34;atom_name&#34;].ljust(3)
        text += (&#34;&#34; if atom[&#34;alt_loc&#34;] is None else atom[&#34;alt_loc&#34;]).ljust(1)
        text += atom[&#34;res_name&#34;].rjust(3) + &#34; &#34;
        text += atom[&#34;chain_id&#34;]
        text += atom[&#34;res_seq&#34;].rjust(4)
        text += atom[&#34;icode&#34;].ljust(1) + &#34;   &#34;
        text += f&#39;{atom[&#34;x&#34;]:8.3f}&#39;
        text += f&#39;{atom[&#34;y&#34;]:8.3f}&#39;
        text += f&#39;{atom[&#34;z&#34;]:8.3f}&#39;
        text += f&#39;{1.0 if atom[&#34;occupancy&#34;] is None else atom[&#34;occupancy&#34;]:6.2f}&#39;
        text += f&#39;{0.0 if atom[&#34;temp_factor&#34;] is None else atom[&#34;temp_factor&#34;]:6.2f}&#39;
        text += &#34;&#34;.ljust(10)
        text += atom[&#34;element&#34;].rjust(2)
        text += (&#34;&#34; if atom[&#34;assigned_charge&#34;] is None else atom[&#34;assigned_charge&#34;]).rjust(2)
        return text

    @staticmethod
    def create_pqr_atom_line(atom: Dict, serial: int, record_name=&#34;ATOM&#34;) -&gt; str:
        &#34;&#34;&#34;
        Creates a ATOM or HETATM line for a PQR file.

        The PQR line is similar to the PDB ATOM line, but with additional fields
        for atomic charge and radius. The occupancy, temperature factor,
        charge and element fields from the PDB file are not used in the PQR file.

        See: https://pdb2pqr.readthedocs.io/en/latest/formats/pqr.html
        The order of fields in a PQR file is as follows:
        Field_name Atom_number Atom_name Residue_name Chain_ID Residue_number
        X Y Z Charge Radius

        Args:
            atom (Dict): The atom information.
            serial (int): The serial number of the atom.
            record_name (str): The record name, should be ATOM or HETATM.

        Returns:
            str: The PQR ATOM or HETATM line.
        &#34;&#34;&#34;
        text = record_name.ljust(6)
        text += str(serial).rjust(5) + &#34; &#34;

        # The PDB spec says that if the element has two characters, e.g. Fe (iron)
        # it should start at the position 13, otherwise it should start at position 14.
        # This seems a little problematic, as some atoms could use 4 characters
        # for example, HG11. The implementation here is consistent with observed PDBs
        # from the RCSB.
        if len(atom[&#34;element&#34;]) == 2 or len(atom[&#34;atom_name&#34;]) == 4:
            text += atom[&#34;atom_name&#34;].ljust(4)
        else:
            text += &#34; &#34; + atom[&#34;atom_name&#34;].ljust(3)
        text += (&#34;&#34; if atom[&#34;alt_loc&#34;] is None else atom[&#34;alt_loc&#34;]).ljust(1)
        text += atom[&#34;res_name&#34;].rjust(3) + &#34; &#34;
        text += atom[&#34;chain_id&#34;]
        text += atom[&#34;res_seq&#34;].rjust(4)
        text += atom[&#34;icode&#34;].ljust(1) + &#34;   &#34;
        text += f&#39;{atom[&#34;x&#34;]:8.3f}&#39;
        text += f&#39;{atom[&#34;y&#34;]:8.3f}&#39;
        text += f&#39;{atom[&#34;z&#34;]:8.3f}&#39;
        text += f&#39;{0.0 if atom[&#34;calculated_charge&#34;] is None else atom[&#34;calculated_charge&#34;]:8.4f}&#39;
        text += f&#39;{0.0 if atom[&#34;radius&#34;] is None else atom[&#34;radius&#34;]:7.4f}&#39;
        # text += f&#39;{1.0 if atom[&#34;occupancy&#34;] is None else atom[&#34;occupancy&#34;]:6.2f}&#39;
        # text += f&#39;{0.0 if atom[&#34;temp_factor&#34;] is None else atom[&#34;temp_factor&#34;]:6.2f}&#39;
        # text += &#34;&#34;.ljust(10)
        # text += atom[&#34;element&#34;].rjust(2)
        # text += (&#34;&#34; if atom[&#34;charge&#34;] is None else atom[&#34;charge&#34;]).rjust(2)

        return text

    # --------------------------------------------------------------------------------
    # Main parsing and saving functions
    # --------------------------------------------------------------------------------

    @staticmethod
    def parse_pdb_entries_from_string(pdb_string: str, is_pqr_format: bool = False):
        &#34;&#34;&#34;
        Parse a PDB file in string format into a list of entries.

        Args:
            pdb_string (str): The PDB file as a string.
            is_pqr_format (bool): If the file is in PQR format.

        Returns:
            List[Dict]: A list of parsed entries.
        &#34;&#34;&#34;

        # Split the string into lines
        lines = pdb_string.split(&#34;\n&#34;)

        # Parse every line into dictionary information
        entries = []
        for line in lines:
            record_name = line[0:6].strip().upper()
            if record_name == &#34;ATOM&#34;:
                pdb_atom_dict = PDBIO.parse_pdb_atom_line(line, is_pqr_format=is_pqr_format)
                entries.append(pdb_atom_dict)
            elif record_name == &#34;HETATM&#34;:
                pdb_atom_dict = PDBIO.parse_pdb_atom_line(line, is_pqr_format=is_pqr_format)
                entries.append(pdb_atom_dict)
            elif record_name == &#34;TER&#34;:
                pdb_ter_dict = PDBIO.parse_pdb_ter_line(line)
                entries.append(pdb_ter_dict)
            elif record_name == &#34;MODEL&#34;:
                pdb_model_dict = PDBIO.parse_pdb_model_line(line)
                entries.append(pdb_model_dict)
            elif record_name == &#34;ENDMDL&#34;:
                pdb_end_model_dict = PDBIO.parse_pdb_end_model_line(line)
                entries.append(pdb_end_model_dict)
            elif record_name == &#34;SEQRES&#34;:
                pdb_seqres_dict = PDBIO.parse_pdb_seqres_line(line)
                entries.append(pdb_seqres_dict)
        return entries


    @staticmethod
    def parse_pdb_entries(file_path: str, is_pqr_format: bool = False):
        &#34;&#34;&#34;
        Parse PDB file according to the spec provided at:
        https://www.wwpdb.org/documentation/file-format-content/format33/sect9.html#ATOM
        &#34;&#34;&#34;
        # Open the file and extract the individual lines.
        with open(file_path) as file:
            pdb_string = file.read()

        return PDBIO.parse_pdb_entries_from_string(pdb_string, is_pqr_format=is_pqr_format)

    @staticmethod
    def load_from_string(pdb_string: str,
                         is_pqr_format: bool = False,
                         pdb_id: Optional[str] = None) -&gt; List[Protein]:
        protein = Protein(pdb_id=pdb_id)
        models = []
        seqres = {}
        current_model = None
        current_chain: Optional[Chain] = None
        current_chain_id = None
        current_residue: Optional[Residue] = None
        current_residue_id = None

        entries = PDBIO.parse_pdb_entries_from_string(pdb_string, is_pqr_format=is_pqr_format)

        for entry in entries:
            record_name = entry[&#34;record_name&#34;]
            if record_name == &#34;SEQRES&#34;:
                chain_id = entry[&#34;chain_id&#34;]
                if chain_id not in seqres:
                    seqres[chain_id] = []
                seqres[chain_id].extend(entry[&#34;residues&#34;])
            elif record_name == &#34;MODEL&#34;:
                # Usually, the MODEL field will only be found in structures based on NMR.
                # We only use the first model in a file if provided.
                # There is nothing to do, so we
                pass
            elif record_name == &#34;ENDMDL&#34;:
                # Usually, the ENDMDL field will only be found in structures based on NMR.
                # it closes a corresponding MODEL field.
                # Since the end of the model is reached, no more entries should be parsed.
                break
            elif record_name == &#34;TER&#34;:
                # The TER field terminates the current chain.
                current_chain = None
                current_chain_id = None
            elif record_name == &#34;ATOM&#34; or record_name == &#34;HETATM&#34;:
                # If we switched chains, set the chain.
                if entry[&#34;chain_id&#34;] != current_chain_id:
                    current_chain_id = entry[&#34;chain_id&#34;]
                    if protein.has_chain(current_chain_id):
                        current_chain = protein.get_chain(current_chain_id)
                    else:
                        current_chain = protein.create_chain(current_chain_id)

                # Check if the residue exists
                residue_id = current_chain_id + entry[&#34;res_seq&#34;] + entry[&#34;icode&#34;]
                if residue_id != current_residue_id:
                    current_residue_id = residue_id
                    if record_name == &#34;ATOM&#34;:
                        # if entry[&#34;res_name&#34;] in ResidueTemplate.VALID_DNA_RESIDUES:
                        #     current_residue = current_chain.add_dna_residue(
                        #         residue_type=entry[&#34;res_name&#34;],
                        #         sequence_no=int(entry[&#34;res_seq&#34;]),
                        #         insertion_code=entry[&#34;icode&#34;]
                        #     )
                        # else:
                        current_residue = Residue(
                            residue_type=entry[&#34;res_name&#34;],
                            sequence_no=int(entry[&#34;res_seq&#34;]),
                            insertion_code=entry[&#34;icode&#34;],
                            chain=current_chain)
                        current_chain.add_residue(current_residue)
                    elif record_name == &#34;HETATM&#34;:
                        current_residue = Residue(
                            residue_type=entry[&#34;res_name&#34;],
                            sequence_no=int(entry[&#34;res_seq&#34;]),
                            insertion_code=entry[&#34;icode&#34;],
                            chain=current_chain)
                        current_chain.add_residue(current_residue)

                        # current_residue = current_chain.add_het_residue(
                        #     residue_type=entry[&#34;res_name&#34;],
                        #     sequence_no=int(entry[&#34;res_seq&#34;]),
                        #     insertion_code=entry[&#34;icode&#34;]
                        # )

                # Temporary fix need to see if anything breaks (For Evo eg. 2HH1 -&gt; HH12)
                # Fix atom naming
                if entry[&#34;atom_name&#34;][0].isnumeric():
                    entry[&#34;atom_name&#34;] = entry[&#34;atom_name&#34;][1:] + entry[&#34;atom_name&#34;][0]
                    if entry[&#34;element&#34;] != &#34;H&#34;:
                        print(0)
                    if entry[&#34;atom_name&#34;][0] == &#34;H&#34;:
                        entry[&#34;element&#34;] = &#34;H&#34;

                # Add the atom to the residue
                # if entry[&#34;alt_loc&#34;] == &#34;&#34;:
                #     atom_id = entry[&#34;atom_name&#34;]
                # else:
                #     atom_id = entry[&#34;atom_name&#34;] + &#34;_&#34; + entry[&#34;alt_loc&#34;]
                atom = Atom(
                    element=entry[&#34;element&#34;],
                    atom_type=entry[&#34;atom_name&#34;],
                    x=entry[&#34;x&#34;],
                    y=entry[&#34;y&#34;],
                    z=entry[&#34;z&#34;],

                    # Serial is dependent on the atom ordering,
                    # so it is not used in the Atom class
                    # pdb_serial=entry[&#34;serial&#34;],
                    alt_loc=entry[&#34;alt_loc&#34;],
                    occupancy=entry[&#34;occupancy&#34;],
                    temp_factor=entry[&#34;temp_factor&#34;],
                    assigned_charge=entry[&#34;assigned_charge&#34;],
                    calculated_charge=entry[&#34;calculated_charge&#34;],
                    radius=entry[&#34;radius&#34;],
                    is_hetero=(record_name == &#34;HETATM&#34;),

                    residue=current_residue
                )

                # current_residue.add_atom(atom_id, atom)
                current_residue.add_atom(atom.atom_type, atom)

        if seqres:
            for chain_id in seqres:
                if seqres[chain_id]:
                    protein.get_chain(chain_id).set_attribute(&#34;seqres&#34;, seqres[chain_id])

        # Housekeeping
        # protein.set_residue_indexing()

        return [protein]


    @staticmethod
    def load(file_path: str,
             is_pqr_format: bool = False,
             pdb_id: Optional[str] = None) -&gt; List[Protein]:
        &#34;&#34;&#34;
        Load a protein from a PDB file.

        Args:
            file_path (str): The path to the PDB file.
            is_pqr_format (bool): If the file is in PQR format.
            pdb_id (str): The PDB ID of the protein.

        Returns:
            List[Protein]: A list of proteins.
        &#34;&#34;&#34;

        # Open the file and extract the individual lines.
        with open(file_path) as file:
            pdb_string = file.read()

        return PDBIO.load_from_string(pdb_string, is_pqr_format=is_pqr_format, pdb_id=pdb_id)

    @staticmethod
    def save_to_string(protein: Protein,
                       is_pqr_format=False) -&gt; str:
        text_entries = []
        num_seqres = 0
        num_atoms = 0
        num_hetatoms = 0
        num_ter = 0
        serial = 1
        atom_entry = None

        for chain in protein.chains:
            for residue in chain.residues:
                for atom in residue.atoms:
                    if not atom.is_hetero:
                        atom_entry = {
                            &#34;element&#34;: atom.element,
                            &#34;atom_name&#34;: atom.atom_type,
                            &#34;alt_loc&#34;: atom.get_attribute(&#34;pdb_alt_loc&#34;),
                            &#34;res_name&#34;: residue.residue_type,
                            &#34;chain_id&#34;: chain.chain_id,
                            &#34;res_seq&#34;: str(residue.sequence_no),
                            &#34;icode&#34;: residue.insertion_code,
                            &#34;x&#34;: atom.x,
                            &#34;y&#34;: atom.y,
                            &#34;z&#34;: atom.z,
                            &#34;occupancy&#34;: atom.get_attribute(&#34;occupancy&#34;),
                            # &#34;temp_factor&#34;: atom._pdb_temp_factor if atom._pdb_temp_factor is not None else 0.0,
                            &#34;temp_factor&#34;: atom.get_attribute(&#34;temp_factor&#34;),
                            &#34;assigned_charge&#34;: atom.get_attribute(&#34;assigned_charge&#34;),
                            &#34;calculated_charge&#34;: atom.get_attribute(&#34;calculated_charge&#34;),
                            &#34;radius&#34;: atom.get_attribute(&#34;radius&#34;)
                        }
                        if not is_pqr_format:
                            text_entries.append(PDBIO.create_pdb_atom_line(atom_entry, serial))
                        else:
                            text_entries.append(PDBIO.create_pqr_atom_line(atom_entry, serial))

                        serial += 1
                        num_atoms += 1

            # TER entry
            if atom_entry is not None:
                text_entries.append(PDBIO.create_pdb_ter_line(serial,
                                                              atom_entry[&#34;res_name&#34;],
                                                              atom_entry[&#34;chain_id&#34;],
                                                              atom_entry[&#34;res_seq&#34;],
                                                              atom_entry[&#34;icode&#34;]))
                serial = serial + 1
                num_ter += 1

        for chain in protein.chains:
            for residue in chain.residues:
                # HETATM entries
                for atom in residue.atoms:
                    if atom.is_hetero:
                        atom_entry = {
                            &#34;element&#34;: atom.element,
                            &#34;atom_name&#34;: atom.atom_type,
                            &#34;alt_loc&#34;: atom.get_attribute(&#34;pdb_alt_loc&#34;),
                            &#34;res_name&#34;: residue.residue_type,
                            &#34;chain_id&#34;: chain.chain_id,
                            &#34;res_seq&#34;: str(residue.sequence_no),
                            &#34;icode&#34;: residue.insertion_code,
                            &#34;x&#34;: atom.x,
                            &#34;y&#34;: atom.y,
                            &#34;z&#34;: atom.z,
                            &#34;occupancy&#34;: atom.get_attribute(&#34;occupancy&#34;),
                            # &#34;temp_factor&#34;: atom._pdb_temp_factor if atom._pdb_temp_factor is not None else 0.0,
                            &#34;temp_factor&#34;: atom.get_attribute(&#34;temp_factor&#34;),
                            &#34;charge&#34;: atom.get_attribute(&#34;assigned_charge&#34;)
                        }
                        if not is_pqr_format:
                            text_entries.append(PDBIO.create_pdb_atom_line(atom_entry, serial, record_name=&#34;HETATM&#34;))
                        else:
                            text_entries.append(PDBIO.create_pqr_atom_line(atom_entry, serial, record_name=&#34;HETATM&#34;))

                        serial += 1
                        num_hetatoms += 1
            # Hetero residues have no TER records, so no need to write a termination code.

        # Bookkeeping records
        text_entries.append(PDBIO.create_pdb_master_line(num_atoms, num_hetatoms, num_ter, num_seqres=num_seqres))
        text_entries.append(&#34;END&#34;.ljust(80))

        return &#34;\n&#34;.join(text_entries)

    @staticmethod
    def save(protein: Protein,
             file_path: str,
             is_pqr_format=False) -&gt; None:

        pdb_string = PDBIO.save_to_string(protein, is_pqr_format=is_pqr_format)

        with open(file_path, &#34;w&#34;) as file:
            file.write(pdb_string)

    # TODO: from_pdb_text and to_pdb_text was added by Claudio
    # The intent is that one should parse proteins from text
    # without working with files. However, a lot of code copying
    # was made and it need to be reworked significantly.

    # @staticmethod
    # def from_pdb_text(lines) -&gt; List[Protein]:
    #     lines = lines.split(&#34;\n&#34;)
    #
    #     entries = []
    #     for line in lines:
    #         record_name = line[0:6].strip().upper()
    #         if record_name == &#34;ATOM&#34;:
    #             pdb_atom_dict = PDBIO.parse_pdb_atom_line(line)
    #             entries.append(pdb_atom_dict)
    #         elif record_name == &#34;HETATM&#34;:
    #             pdb_atom_dict = PDBIO.parse_pdb_atom_line(line)
    #             entries.append(pdb_atom_dict)
    #         elif record_name == &#34;TER&#34;:
    #             pdb_ter_dict = PDBIO.parse_pdb_ter_line(line)
    #             entries.append(pdb_ter_dict)
    #         elif record_name == &#34;MODEL&#34;:
    #             pdb_model_dict = PDBIO.parse_pdb_model_line(line)
    #             entries.append(pdb_model_dict)
    #         elif record_name == &#34;ENDMDL&#34;:
    #             pdb_end_model_dict = PDBIO.parse_pdb_end_model_line(line)
    #             entries.append(pdb_end_model_dict)
    #         elif record_name == &#34;SEQRES&#34;:
    #             pdb_seqres_dict = PDBIO.parse_pdb_seqres_line(line)
    #             entries.append(pdb_seqres_dict)
    #
    #     protein = Protein()
    #     models = []
    #     seqres = {}
    #     current_model = None
    #     current_chain: Optional[Chain] = None
    #     current_chain_id = None
    #     current_residue: Optional[Residue] = None
    #     current_residue_id = None
    #
    #     for entry in entries:
    #         record_name = entry[&#34;record_name&#34;]
    #         if record_name == &#34;SEQRES&#34;:
    #             chain_id = entry[&#34;chain_id&#34;]
    #             if chain_id not in seqres:
    #                 seqres[chain_id] = []
    #             seqres[chain_id].extend(entry[&#34;residues&#34;])
    #         elif record_name == &#34;MODEL&#34;:
    #             # Usually, the MODEL field will only be found in structures based on NMR.
    #             # We only use the first model in a file if provided.
    #             # There is nothing to do, so we
    #             pass
    #         elif record_name == &#34;ENDMDL&#34;:
    #             # Usually, the ENDMDL field will only be found in structures based on NMR.
    #             # it closes a corresponding MODEL field.
    #             # Since the end of the model is reached, no more entries should be parsed.
    #             break
    #         elif record_name == &#34;TER&#34;:
    #             # The TER field terminates the current chain.
    #             current_chain = None
    #             current_chain_id = None
    #         elif record_name == &#34;ATOM&#34; or record_name == &#34;HETATM&#34;:
    #             # If we switched chains, set the chain.
    #             if entry[&#34;chain_id&#34;] != current_chain_id:
    #                 current_chain_id = entry[&#34;chain_id&#34;]
    #                 if protein.has_chain(current_chain_id):
    #                     current_chain = protein.get_chain(current_chain_id)
    #                 else:
    #                     current_chain = protein.create_chain(current_chain_id)
    #
    #             # Check if the residue exists
    #             residue_id = current_chain_id + entry[&#34;res_seq&#34;] + entry[&#34;icode&#34;]
    #             if residue_id != current_residue_id:
    #                 current_residue_id = residue_id
    #                 if record_name == &#34;ATOM&#34;:
    #                     # if entry[&#34;res_name&#34;] in ResidueTemplate.VALID_DNA_RESIDUES:
    #                     #     current_residue = current_chain.add_dna_residue(
    #                     #         residue_type=entry[&#34;res_name&#34;],
    #                     #         sequence_no=int(entry[&#34;res_seq&#34;]),
    #                     #         insertion_code=entry[&#34;icode&#34;]
    #                     #     )
    #                     # else:
    #                     current_residue = Residue(
    #                         residue_type=entry[&#34;res_name&#34;],
    #                         sequence_no=int(entry[&#34;res_seq&#34;]),
    #                         insertion_code=entry[&#34;icode&#34;],
    #                         chain=current_chain)
    #                     current_chain.add_residue(current_residue)
    #                 elif record_name == &#34;HETATM&#34;:
    #                     current_residue = Residue(
    #                         residue_type=entry[&#34;res_name&#34;],
    #                         sequence_no=int(entry[&#34;res_seq&#34;]),
    #                         insertion_code=entry[&#34;icode&#34;],
    #                         chain=current_chain)
    #                     current_chain.add_residue(current_residue)
    #
    #                     # current_residue = current_chain.add_het_residue(
    #                     #     residue_type=entry[&#34;res_name&#34;],
    #                     #     sequence_no=int(entry[&#34;res_seq&#34;]),
    #                     #     insertion_code=entry[&#34;icode&#34;]
    #                     # )
    #
    #             # Temporary fix need to see if anything breaks (For Evo eg. 2HH1 -&gt; HH12)
    #             # Fix atom naming
    #             if entry[&#34;atom_name&#34;][0].isnumeric():
    #                 entry[&#34;atom_name&#34;] = entry[&#34;atom_name&#34;][1:] + entry[&#34;atom_name&#34;][0]
    #                 if entry[&#34;element&#34;] != &#34;H&#34;:
    #                     print(0)
    #                 if entry[&#34;atom_name&#34;][0] == &#34;H&#34;:
    #                     entry[&#34;element&#34;] = &#34;H&#34;
    #
    #             # Add the atom to the residue
    #             if entry[&#34;alt_loc&#34;] == &#34;&#34;:
    #                 atom_id = entry[&#34;atom_name&#34;]
    #             else:
    #                 atom_id = entry[&#34;atom_name&#34;] + &#34;_&#34; + entry[&#34;alt_loc&#34;]
    #             atom = Atom(
    #                 element=entry[&#34;element&#34;],
    #                 atom_type=entry[&#34;atom_name&#34;],
    #                 x=entry[&#34;x&#34;],
    #                 y=entry[&#34;y&#34;],
    #                 z=entry[&#34;z&#34;],
    #
    #                 # pdb_serial=entry[&#34;serial&#34;],
    #                 # pdb_alt_loc=entry[&#34;alt_loc&#34;],
    #                 # pdb_occupancy=entry[&#34;occupancy&#34;],
    #                 # pdb_temp_factor=entry[&#34;temp_factor&#34;],
    #                 # pdb_assigned_charge=entry[&#34;assigned_charge&#34;],
    #                 # pqr_calculated_charge=entry[&#34;calculated_charge&#34;],
    #                 # pqr_radius=entry[&#34;radius&#34;],
    #                 #
    #                 is_hetero=(record_name == &#34;HETATM&#34;),
    #
    #                 residue=current_residue
    #             )
    #             current_residue.add_atom(atom_id, atom)
    #
    #     # if seqres:
    #     #     for chain_id in seqres:
    #     #         if seqres[chain_id]:
    #     #             protein.chains[chain_id].sequence = seqres[chain_id]
    #
    #     # Housekeeping
    #     # protein.set_residue_indexing()
    #
    #     return [protein]

    # @staticmethod
    # def to_pdb_text(protein: Protein):
    #     text_entries = &#34;&#34;
    #     num_seqres = 0
    #     num_atoms = 0
    #     num_hetatoms = 0
    #     num_ter = 0
    #     serial = 1
    #
    #     for chain in protein.chains:
    #         for residue in chain.residues:
    #             for atom in residue.atoms:
    #                 if not atom.is_hetero:
    #                     atom_entry = {
    #                         &#34;element&#34;: atom.element,
    #                         &#34;atom_name&#34;: atom.atom_type,
    #                         &#34;alt_loc&#34;: atom.get_attribute(&#34;pdb_alt_loc&#34;),
    #                         &#34;res_name&#34;: residue.residue_type,
    #                         &#34;chain_id&#34;: chain.chain_id,
    #                         &#34;res_seq&#34;: str(residue.sequence_no),
    #                         &#34;icode&#34;: residue.insertion_code,
    #                         &#34;x&#34;: atom.x,
    #                         &#34;y&#34;: atom.y,
    #                         &#34;z&#34;: atom.z,
    #                         &#34;occupancy&#34;: atom.get_attribute(&#34;occupancy&#34;),
    #                         # &#34;temp_factor&#34;: atom._pdb_temp_factor if atom._pdb_temp_factor is not None else 0.0,
    #                         &#34;temp_factor&#34;: atom.get_attribute(&#34;temp_factor&#34;),
    #                         &#34;charge&#34;: atom.get_attribute(&#34;assigned_charge&#34;)
    #                     }
    #                     text_entries += PDBIO.create_pdb_atom_line(atom_entry, serial)
    #                     text_entries += &#34;\n&#34;
    #                     serial += 1
    #                     num_atoms += 1
    #
    #     # Bookkeeping records
    #     text_entries += PDBIO.create_pdb_master_line(num_atoms, num_hetatoms, num_ter, num_seqres=num_seqres)
    #     text_entries += &#34;END&#34;.ljust(80)
    #     text_entries += &#34;\n&#34;
    #
    #     return text_entries

    # @staticmethod
    # def save_to_pdb(file_path: str, protein):
    #     entries = []
    #
    #     num_seqres = 0
    #     num_atoms = 0
    #     num_hetatoms = 0
    #     num_ter = 0
    #     serial = 1
    #
    #     for chain in protein.chains:
    #         for residue in chain.residues:
    #             # ATOM entries
    #             for atom in residue.atoms:
    #                 if not atom.is_hetero:
    #                     atom_entry = {
    #                         &#34;element&#34;: atom.element,
    #                         &#34;atom_name&#34;: atom.atom_type,
    #                         &#34;alt_loc&#34;: atom._pdb_alt_loc,
    #                         &#34;res_name&#34;: residue.residue_type,
    #                         &#34;chain_id&#34;: chain.chain_id,
    #                         &#34;res_seq&#34;: str(residue._pdb_sequence_no),
    #                         &#34;icode&#34;: residue._pdb_insertion_code,
    #                         &#34;x&#34;: atom.x,
    #                         &#34;y&#34;: atom.y,
    #                         &#34;z&#34;: atom.z,
    #                         &#34;occupancy&#34;: atom._pdb_occupancy,
    #                         &#34;temp_factor&#34;: atom._pdb_temp_factor if atom._pdb_temp_factor is not None else 0.0,
    #                         &#34;charge&#34;: atom._pdb_assigned_charge
    #                     }
    #                     entries.append(PDBParser.create_pdb_atom_line(atom_entry, serial))
    #                     serial += 1
    #                     num_atoms += 1
    #
    #         # TER entry
    #         if chain.num_residues - chain.num_hetero_residues &gt; 0:
    #             entries.append(
    #                 PDBParser.create_pdb_ter_line(serial, atom_entry[&#34;res_name&#34;], chain.chain_id, atom_entry[&#34;res_seq&#34;],
    #                                               atom_entry[&#34;icode&#34;]))
    #             serial = serial + 1
    #             num_ter += 1
    #
    #     for chain in protein.chains:
    #         for residue in chain.residues:
    #             # HETATM entries
    #             for atom in residue.atoms:
    #                 if atom.is_hetero:
    #                     atom_entry = {
    #                         &#34;element&#34;: atom.element,
    #                         &#34;atom_name&#34;: atom.atom_type,
    #                         &#34;alt_loc&#34;: atom._pdb_alt_loc,
    #                         &#34;res_name&#34;: residue.residue_type,
    #                         &#34;chain_id&#34;: chain.chain_id,
    #                         &#34;res_seq&#34;: str(residue._pdb_sequence_no),
    #                         &#34;icode&#34;: residue._pdb_insertion_code,
    #                         &#34;x&#34;: atom.x,
    #                         &#34;y&#34;: atom.y,
    #                         &#34;z&#34;: atom.z,
    #                         &#34;occupancy&#34;: atom._pdb_occupancy,
    #                         &#34;temp_factor&#34;: atom._pdb_temp_factor if atom._pdb_temp_factor is not None else 0.0,
    #                         &#34;charge&#34;: atom._pdb_assigned_charge
    #                     }
    #                     entries.append(PDBParser.create_pdb_atom_line(atom_entry, serial, &#34;HETATM&#34;))
    #                     serial += 1
    #                     num_hetatoms += 1
    #
    #         # Hetero residues have no TER records, so no need to write a termination code.
    #
    #     # Bookkeeping records
    #     entries.append(PDBParser.create_pdb_master_line(num_atoms, num_hetatoms, num_ter, num_seqres=num_seqres))
    #     entries.append(&#34;END&#34;.ljust(80))
    #
    #     # Write file
    #     with open(file_path, &#34;w&#34;) as file:
    #         file.write(&#34;\n&#34;.join(entries))

    # @staticmethod
    # def load_from_pdb(file_path: str):
    #     entries = PDBParser.parse_pdb_entries(file_path)
    #
    #     protein = Protein()
    #     models = []
    #     seqres = {}
    #     current_model = None
    #     current_chain: Chain = None
    #     current_chain_id = None
    #     current_residue: Residue = None
    #     current_residue_id = None
    #
    #     for entry in entries:
    #         record_name = entry[&#34;record_name&#34;]
    #         if record_name == &#34;SEQRES&#34;:
    #             chain_id = entry[&#34;chain_id&#34;]
    #             if chain_id not in seqres:
    #                 seqres[chain_id] = []
    #             seqres[chain_id].extend(entry[&#34;residues&#34;])
    #         elif record_name == &#34;MODEL&#34;:
    #             # Usually, the MODEL field will only be found in structures based on NMR.
    #             # We only use the first model in a file if provided.
    #             # There is nothing to do, so we
    #             pass
    #         elif record_name == &#34;ENDMDL&#34;:
    #             # Usually, the ENDMDL field will only be found in structures based on NMR.
    #             # it closes a corresponding MODEL field.
    #             # Since the end of the model is reached, no more entries should be parsed.
    #             break
    #         elif record_name == &#34;TER&#34;:
    #             # The TER field terminates the current chain.
    #             current_chain = None
    #             current_chain_id = None
    #         elif record_name == &#34;ATOM&#34; or record_name == &#34;HETATM&#34;:
    #             # If we switched chains, set the chain.
    #             if entry[&#34;chain_id&#34;] != current_chain_id:
    #                 current_chain_id = entry[&#34;chain_id&#34;]
    #                 if current_chain_id in protein._chains:
    #                     current_chain = protein._chains[current_chain_id]
    #                 else:
    #                     current_chain = protein.create_chain(current_chain_id)
    #
    #             # Check if the residue exists
    #             residue_id = current_chain_id + entry[&#34;res_seq&#34;] + entry[&#34;icode&#34;]
    #             if residue_id != current_residue_id:
    #                 current_residue_id = residue_id
    #                 if record_name == &#34;ATOM&#34;:
    #                     # if entry[&#34;res_name&#34;] in ResidueTemplate.VALID_DNA_RESIDUES:
    #                     #     current_residue = current_chain.add_dna_residue(
    #                     #         residue_type=entry[&#34;res_name&#34;],
    #                     #         sequence_no=int(entry[&#34;res_seq&#34;]),
    #                     #         insertion_code=entry[&#34;icode&#34;]
    #                     #     )
    #                     # else:
    #                     current_residue = Residue(
    #                         residue_type=entry[&#34;res_name&#34;],
    #                         pdb_sequence_no=int(entry[&#34;res_seq&#34;]),
    #                         pdb_insertion_code=entry[&#34;icode&#34;],
    #                         chain=current_chain)
    #                     current_chain.add_residue(current_residue)
    #                 elif record_name == &#34;HETATM&#34;:
    #                     current_residue = Residue(
    #                         residue_type=entry[&#34;res_name&#34;],
    #                         pdb_sequence_no=int(entry[&#34;res_seq&#34;]),
    #                         pdb_insertion_code=entry[&#34;icode&#34;],
    #                         chain=current_chain)
    #                     current_chain.add_residue(current_residue)
    #
    #                     # current_residue = current_chain.add_het_residue(
    #                     #     residue_type=entry[&#34;res_name&#34;],
    #                     #     sequence_no=int(entry[&#34;res_seq&#34;]),
    #                     #     insertion_code=entry[&#34;icode&#34;]
    #                     # )
    #
    #             # Temporary fix need to see if anything breaks (For Evo eg. 2HH1 -&gt; HH12)
    #             # Fix atom naming
    #             if entry[&#34;atom_name&#34;][0].isnumeric():
    #                 entry[&#34;atom_name&#34;] = entry[&#34;atom_name&#34;][1:] + entry[&#34;atom_name&#34;][0]
    #                 if entry[&#34;element&#34;] != &#34;H&#34;:
    #                     print(0)
    #                 if entry[&#34;atom_name&#34;][0] == &#34;H&#34;:
    #                     entry[&#34;element&#34;] = &#34;H&#34;
    #
    #             # Add the atom to the residue
    #             if entry[&#34;alt_loc&#34;] == &#34;&#34;:
    #                 atom_id = entry[&#34;atom_name&#34;]
    #             else:
    #                 atom_id = entry[&#34;atom_name&#34;] + &#34;_&#34; + entry[&#34;alt_loc&#34;]
    #             atom = Atom(
    #                 element=entry[&#34;element&#34;],
    #                 atom_type=entry[&#34;atom_name&#34;],
    #                 x=entry[&#34;x&#34;],
    #                 y=entry[&#34;y&#34;],
    #                 z=entry[&#34;z&#34;],
    #
    #                 pdb_serial=entry[&#34;serial&#34;],
    #                 pdb_alt_loc=entry[&#34;alt_loc&#34;],
    #                 pdb_occupancy=entry[&#34;occupancy&#34;],
    #                 pdb_temp_factor=entry[&#34;temp_factor&#34;],
    #                 pdb_assigned_charge=entry[&#34;assigned_charge&#34;],
    #                 pqr_calculated_charge=entry[&#34;calculated_charge&#34;],
    #                 pqr_radius=entry[&#34;radius&#34;],
    #
    #                 is_hetero=(record_name == &#34;HETATM&#34;),
    #
    #                 residue=current_residue
    #             )
    #             current_residue.add_atom(atom_id, atom)
    #
    #     # if seqres:
    #     #     for chain_id in seqres:
    #     #         if seqres[chain_id]:
    #     #             protein.chains[chain_id].sequence = seqres[chain_id]
    #
    #     # Housekeeping
    #     protein.set_residue_indexing()
    #
    #     return protein</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="protkit.file_io.pdb_io.PDBIO"><code class="flex name class">
<span>class <span class="ident">PDBIO</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PDBIO():
    # --------------------------------------------------------------------------------
    # MODEL
    # --------------------------------------------------------------------------------

    @staticmethod
    def parse_pdb_model_line(line: str):
        &#34;&#34;&#34;
        Parse a MODEL (start model) line from a PDB file.

        COLUMNS        DATA  TYPE    FIELD          DEFINITION
        ---------------------------------------------------------------------------------------
         1 -  6        Record name   &#34;MODEL &#34;
        11 - 14        Integer       serial         Model serial number.
        &#34;&#34;&#34;
        pdb_model_dict = {
            &#34;record_name&#34;: &#34;MODEL&#34;,
            &#34;serial&#34;: line[10:14]
        }

        return pdb_model_dict

    @staticmethod
    def create_pdb_model_line(serial: int):
        &#34;&#34;&#34;
        Creates a MODEL (start model) line for a PDB file.
        &#34;&#34;&#34;
        return &#34;MODEL&#34;.ljust(10) + str(serial).rjust(4) + &#34;&#34;.ljust(66)

    # --------------------------------------------------------------------------------
    # ENDMDL
    # --------------------------------------------------------------------------------

    @staticmethod
    def parse_pdb_end_model_line(line: str):
        &#34;&#34;&#34;
        Parse a ENDMDL (end model) line from a PDB file.

        COLUMNS       DATA  TYPE     FIELD        DEFINITION
        ------------------------------------------------------------------
        1 - 6         Record name   &#34;ENDMDL&#34;

        &#34;&#34;&#34;
        pdb_end_model_dict = {
            &#34;record_name&#34;: &#34;ENDMDL&#34;
        }

        return pdb_end_model_dict

    @staticmethod
    def create_pdb_end_model_line():
        &#34;&#34;&#34;
        Creates a ENDMDL (end model) line for a PDB file.
        &#34;&#34;&#34;
        return &#34;ENDMDL&#34;.ljust(80)

    # --------------------------------------------------------------------------------
    # MASTER
    # --------------------------------------------------------------------------------

    @staticmethod
    def create_pdb_master_line(num_atoms, num_hetatoms, num_ter, num_remark=0, num_het=0, num_helix=0, num_sheet=0,
                               num_site=0, num_trans=0, num_conect=0, num_seqres=0):
        &#34;&#34;&#34;
        Creates a MASTER (recordkeeping) line for a PDB file.

        COLUMNS         DATA TYPE     FIELD          DEFINITION
        ----------------------------------------------------------------------------------
         1 -  6         Record name   &#34;MASTER&#34;
        11 - 15         Integer       numRemark      Number of REMARK records
        16 - 20         Integer       &#34;0&#34;
        21 - 25         Integer       numHet         Number of HET records
        26 - 30         Integer       numHelix       Number of HELIX records
        31 - 35         Integer       numSheet       Number of SHEET records
        36 - 40         Integer       numTurn        deprecated
        41 - 45         Integer       numSite        Number of SITE records
        46 - 50         Integer       numXform       Number of coordinate transformation
                                                     records  (ORIGX+SCALE+MTRIX)
        51 - 55         Integer       numCoord       Number of atomic coordinate records
                                                     records (ATOM+HETATM)
        56 - 60         Integer       numTer         Number of TER records
        61 - 65         Integer       numConect      Number of CONECT records
        66 - 70         Integer       numSeq         Number of SEQRES records
        &#34;&#34;&#34;

        entries = [
            &#34;MASTER&#34;.ljust(10),
            str(num_remark).rjust(5),
            &#34;0&#34;.rjust(5),
            str(num_het).rjust(5),
            str(num_helix).rjust(5),
            str(num_sheet).rjust(5),
            &#34;0&#34;.rjust(5),
            str(num_site).rjust(5),
            str(num_trans).rjust(5),
            str(num_atoms + num_hetatoms).rjust(5),
            str(num_ter).rjust(5),
            str(num_conect).rjust(5),
            str(num_seqres).rjust(5),
            &#34;&#34;.ljust(10)
        ]

        return &#34;&#34;.join(entries)

    # --------------------------------------------------------------------------------
    # SEQRES
    # --------------------------------------------------------------------------------

    @staticmethod
    def parse_pdb_seqres_line(line: str):
        &#34;&#34;&#34;
        Parse a SEQRES (sequence) line from a PDB file.
        &#34;&#34;&#34;
        pdb_seqres_dict = {
            &#34;record_name&#34;: &#34;SEQRES&#34;,
            &#34;chain_id&#34;: line[11],
            &#34;residues&#34;: line[19:].strip().split()
        }

        return pdb_seqres_dict

    @staticmethod
    def create_seqres_line(line_no, chain_id, num_residues, residues):
        &#34;&#34;&#34;
        Creates a SEQRES (sequence) line for a PDB file.

         1 -  6        Record name    &#34;SEQRES&#34;
         8 - 10        Integer        serNum       Serial number of the SEQRES record for  the
                                                   current  chain. Starts at 1 and increments
                                                   by one  each line. Reset to 1 for each chain.
        12             Character      chainID      Chain identifier. This may be any single
                                                   legal  character, including a blank which
                                                   is used if there is only one chain.
        14 - 17        Integer        numRes       Number of residues in the chain.
                                                   This  value is repeated on every record.
        20 - 22        Residue name   resName      Residue name.
        24 - 26        Residue name   resName      Residue name.
        28 - 30        Residue name   resName      Residue name.
        32 - 34        Residue name   resName      Residue name.
        36 - 38        Residue name   resName      Residue name.
        40 - 42        Residue name   resName      Residue name.
        44 - 46        Residue name   resName      Residue name.
        48 - 50        Residue name   resName      Residue name.
        52 - 54        Residue name   resName      Residue name.
        56 - 58        Residue name   resName      Residue name.
        60 - 62        Residue name   resName      Residue name.
        64 - 66        Residue name   resName      Residue name.
        68 - 70        Residue name   resName      Residue name.
        &#34;&#34;&#34;
        entries = [
            &#34;SEQRES &#34;,
            str(line_no).rjust(3) + &#34; &#34;,
            chain_id + &#34; &#34;,
            str(num_residues).rjust(4) + &#34;  &#34;
        ]
        for residue in residues:
            entries.append(residue[&#34;residue&#34;].rjust(3) + &#34; &#34;)
        return &#34;&#34;.join(entries).ljust(80)

    # --------------------------------------------------------------------------------
    # TER
    # --------------------------------------------------------------------------------

    @staticmethod
    def parse_pdb_ter_line(line: str):
        &#34;&#34;&#34;
        Parse a TER (chain termination) line from a PDB file.

        COLUMNS        DATA  TYPE    FIELD           DEFINITION
        -------------------------------------------------------------------------
         1 -  6        Record name   &#34;TER   &#34;
         7 - 11        Integer       serial          Serial number.
        18 - 20        Residue name  resName         Residue name.
        22             Character     chainID         Chain identifier.
        23 - 26        Integer       resSeq          Residue sequence number.
        27             AChar         iCode           Insertion code.

        &#34;&#34;&#34;
        if line == &#34;TER&#34;:
            pdb_ter_dict = {
                &#34;record_name&#34;: &#34;TER&#34;,
                &#34;serial&#34;: &#34;&#34;,
                &#34;res_name&#34;: &#34;&#34;,
                &#34;chain_id&#34;: &#34;&#34;,
                &#34;res_seq&#34;: &#34;&#34;,
                &#34;icode&#34;: &#34;&#34;
            }
        else:
            line = line.ljust(80)
            pdb_ter_dict = {
                &#34;record_name&#34;: &#34;TER&#34;,
                &#34;serial&#34;: line[6:11],
                &#34;res_name&#34;: line[17:21],
                &#34;chain_id&#34;: line[21],
                &#34;res_seq&#34;: line[22:26],
                &#34;icode&#34;: line[26]
            }
        return pdb_ter_dict

    @staticmethod
    def create_pdb_ter_line(serial, res_name, chain_id, res_seq, icode):
        &#34;&#34;&#34;
        Creates a TER (chain termination) line for a PDB file.
        &#34;&#34;&#34;
        text = &#34;TER&#34;.ljust(6)
        text += str(serial).rjust(5) + &#34;      &#34;
        text += res_name.rjust(3) + &#34; &#34;
        text += chain_id
        text += res_seq.rjust(4)
        text += icode.ljust(1)

        return text.ljust(80)

    # --------------------------------------------------------------------------------
    # ATOM | HETATM
    # --------------------------------------------------------------------------------

    @staticmethod
    def parse_pdb_atom_line(line, is_pqr_format: bool = False):
        &#34;&#34;&#34;
        Parse a ATOM (individual atom) or HETATM (hetero atom) line from a PDB file.

        COLUMNS        DATA  TYPE    FIELD        DEFINITION
        -------------------------------------------------------------------------------------
         1 -  6        Record name   &#34;ATOM  &#34;
         7 - 11        Integer       serial       Atom  serial number.
        13 - 16        Atom          name         Atom name.
        17             Character     altLoc       Alternate location indicator.
        18 - 20        Residue name  resName      Residue name.
        22             Character     chainID      Chain identifier.
        23 - 26        Integer       resSeq       Residue sequence number.
        27             AChar         iCode        Code for insertion of residues.
        31 - 38        Real(8.3)     x            Orthogonal coordinates for X in Angstroms.
        39 - 46        Real(8.3)     y            Orthogonal coordinates for Y in Angstroms.
        47 - 54        Real(8.3)     z            Orthogonal coordinates for Z in Angstroms.
        55 - 60        Real(6.2)     occupancy    Occupancy.
        61 - 66        Real(6.2)     tempFactor   Temperature  factor.
        77 - 78        LString(2)    element      Element symbol, right-justified.
        79 - 80        LString(2)    charge       Charge  on the atom.`
        &#34;&#34;&#34;
        if not is_pqr_format:
            pdb_atom_dict = {
                &#34;record_name&#34;: line[0:6].strip().upper(),
                &#34;serial&#34;: line[6:11].strip(),
                # Open space
                &#34;atom_name&#34;: line[12:16].strip(),
                &#34;alt_loc&#34;: line[16].strip(),
                &#34;res_name&#34;: line[17:20].strip(),
                # Open space
                &#34;chain_id&#34;: line[21].strip(),
                &#34;res_seq&#34;: line[22:26].strip(),
                &#34;icode&#34;: line[26].strip(),
                # 3x Open space
                &#34;x&#34;: float(line[30:38]),
                &#34;y&#34;: float(line[38:46]),
                &#34;z&#34;: float(line[46:54]),
                &#34;occupancy&#34;: float(line[54:60]),
                # &#34;temp_factor&#34;: None,
                &#34;temp_factor&#34;: float(line[60:66]),
                # 66 - 75?
                &#34;element&#34;: line[76:78].strip(),
                &#34;assigned_charge&#34;: line[78:80].strip(),
                &#34;calculated_charge&#34;: None,
                &#34;radius&#34;: None
            }
        else:
            pdb_atom_dict = {
                &#34;record_name&#34;: line[0:6].strip().upper(),
                &#34;serial&#34;: line[6:11].strip(),
                # Open space
                &#34;atom_name&#34;: line[12:16].strip(),
                &#34;alt_loc&#34;: line[16].strip(),
                &#34;res_name&#34;: line[17:20].strip(),
                # Open space
                &#34;chain_id&#34;: line[21].strip(),
                &#34;res_seq&#34;: line[22:26].strip(),
                &#34;icode&#34;: line[26].strip(),
                # 3x Open space
                &#34;x&#34;: float(line[30:38]),
                &#34;y&#34;: float(line[38:46]),
                &#34;z&#34;: float(line[46:54]),

                &#34;occupancy&#34;: 1.0,
                &#34;temp_factor&#34;: None,

                &#34;element&#34;: line[76:78].strip(),
                &#34;assigned_charge&#34;: None,
                &#34;calculated_charge&#34;: float(line[54:62]),
                &#34;radius&#34;: float(line[62:70])
            }
        return pdb_atom_dict

    @staticmethod
    def create_pdb_atom_line(atom: Dict, serial: int, record_name=&#34;ATOM&#34;) -&gt; str:
        &#34;&#34;&#34;
        Creates a ATOM or HETATM line for a PDB file.

        Args:
            atom (Dict): The atom information.
            serial (int): The serial number of the atom.
            record_name (str): The record name, should be ATOM or HETATM.

        Returns:
            str: The ATOM or HETATM line.
        &#34;&#34;&#34;
        text = record_name.ljust(6)
        text += str(serial).rjust(5) + &#34; &#34;

        # The PDB spec says that if the element has two characters, e.g. Fe (iron)
        # it should start at the position 13, otherwise it should start at position 14.
        # This seems a little problematic, as some atoms could use 4 characters
        # for example, HG11. The implementation here is consistent with observed PDBs
        # from the RCSB.
        if len(atom[&#34;element&#34;]) == 2 or len(atom[&#34;atom_name&#34;]) == 4:
            text += atom[&#34;atom_name&#34;].ljust(4)
        else:
            text += &#34; &#34; + atom[&#34;atom_name&#34;].ljust(3)
        text += (&#34;&#34; if atom[&#34;alt_loc&#34;] is None else atom[&#34;alt_loc&#34;]).ljust(1)
        text += atom[&#34;res_name&#34;].rjust(3) + &#34; &#34;
        text += atom[&#34;chain_id&#34;]
        text += atom[&#34;res_seq&#34;].rjust(4)
        text += atom[&#34;icode&#34;].ljust(1) + &#34;   &#34;
        text += f&#39;{atom[&#34;x&#34;]:8.3f}&#39;
        text += f&#39;{atom[&#34;y&#34;]:8.3f}&#39;
        text += f&#39;{atom[&#34;z&#34;]:8.3f}&#39;
        text += f&#39;{1.0 if atom[&#34;occupancy&#34;] is None else atom[&#34;occupancy&#34;]:6.2f}&#39;
        text += f&#39;{0.0 if atom[&#34;temp_factor&#34;] is None else atom[&#34;temp_factor&#34;]:6.2f}&#39;
        text += &#34;&#34;.ljust(10)
        text += atom[&#34;element&#34;].rjust(2)
        text += (&#34;&#34; if atom[&#34;assigned_charge&#34;] is None else atom[&#34;assigned_charge&#34;]).rjust(2)
        return text

    @staticmethod
    def create_pqr_atom_line(atom: Dict, serial: int, record_name=&#34;ATOM&#34;) -&gt; str:
        &#34;&#34;&#34;
        Creates a ATOM or HETATM line for a PQR file.

        The PQR line is similar to the PDB ATOM line, but with additional fields
        for atomic charge and radius. The occupancy, temperature factor,
        charge and element fields from the PDB file are not used in the PQR file.

        See: https://pdb2pqr.readthedocs.io/en/latest/formats/pqr.html
        The order of fields in a PQR file is as follows:
        Field_name Atom_number Atom_name Residue_name Chain_ID Residue_number
        X Y Z Charge Radius

        Args:
            atom (Dict): The atom information.
            serial (int): The serial number of the atom.
            record_name (str): The record name, should be ATOM or HETATM.

        Returns:
            str: The PQR ATOM or HETATM line.
        &#34;&#34;&#34;
        text = record_name.ljust(6)
        text += str(serial).rjust(5) + &#34; &#34;

        # The PDB spec says that if the element has two characters, e.g. Fe (iron)
        # it should start at the position 13, otherwise it should start at position 14.
        # This seems a little problematic, as some atoms could use 4 characters
        # for example, HG11. The implementation here is consistent with observed PDBs
        # from the RCSB.
        if len(atom[&#34;element&#34;]) == 2 or len(atom[&#34;atom_name&#34;]) == 4:
            text += atom[&#34;atom_name&#34;].ljust(4)
        else:
            text += &#34; &#34; + atom[&#34;atom_name&#34;].ljust(3)
        text += (&#34;&#34; if atom[&#34;alt_loc&#34;] is None else atom[&#34;alt_loc&#34;]).ljust(1)
        text += atom[&#34;res_name&#34;].rjust(3) + &#34; &#34;
        text += atom[&#34;chain_id&#34;]
        text += atom[&#34;res_seq&#34;].rjust(4)
        text += atom[&#34;icode&#34;].ljust(1) + &#34;   &#34;
        text += f&#39;{atom[&#34;x&#34;]:8.3f}&#39;
        text += f&#39;{atom[&#34;y&#34;]:8.3f}&#39;
        text += f&#39;{atom[&#34;z&#34;]:8.3f}&#39;
        text += f&#39;{0.0 if atom[&#34;calculated_charge&#34;] is None else atom[&#34;calculated_charge&#34;]:8.4f}&#39;
        text += f&#39;{0.0 if atom[&#34;radius&#34;] is None else atom[&#34;radius&#34;]:7.4f}&#39;
        # text += f&#39;{1.0 if atom[&#34;occupancy&#34;] is None else atom[&#34;occupancy&#34;]:6.2f}&#39;
        # text += f&#39;{0.0 if atom[&#34;temp_factor&#34;] is None else atom[&#34;temp_factor&#34;]:6.2f}&#39;
        # text += &#34;&#34;.ljust(10)
        # text += atom[&#34;element&#34;].rjust(2)
        # text += (&#34;&#34; if atom[&#34;charge&#34;] is None else atom[&#34;charge&#34;]).rjust(2)

        return text

    # --------------------------------------------------------------------------------
    # Main parsing and saving functions
    # --------------------------------------------------------------------------------

    @staticmethod
    def parse_pdb_entries_from_string(pdb_string: str, is_pqr_format: bool = False):
        &#34;&#34;&#34;
        Parse a PDB file in string format into a list of entries.

        Args:
            pdb_string (str): The PDB file as a string.
            is_pqr_format (bool): If the file is in PQR format.

        Returns:
            List[Dict]: A list of parsed entries.
        &#34;&#34;&#34;

        # Split the string into lines
        lines = pdb_string.split(&#34;\n&#34;)

        # Parse every line into dictionary information
        entries = []
        for line in lines:
            record_name = line[0:6].strip().upper()
            if record_name == &#34;ATOM&#34;:
                pdb_atom_dict = PDBIO.parse_pdb_atom_line(line, is_pqr_format=is_pqr_format)
                entries.append(pdb_atom_dict)
            elif record_name == &#34;HETATM&#34;:
                pdb_atom_dict = PDBIO.parse_pdb_atom_line(line, is_pqr_format=is_pqr_format)
                entries.append(pdb_atom_dict)
            elif record_name == &#34;TER&#34;:
                pdb_ter_dict = PDBIO.parse_pdb_ter_line(line)
                entries.append(pdb_ter_dict)
            elif record_name == &#34;MODEL&#34;:
                pdb_model_dict = PDBIO.parse_pdb_model_line(line)
                entries.append(pdb_model_dict)
            elif record_name == &#34;ENDMDL&#34;:
                pdb_end_model_dict = PDBIO.parse_pdb_end_model_line(line)
                entries.append(pdb_end_model_dict)
            elif record_name == &#34;SEQRES&#34;:
                pdb_seqres_dict = PDBIO.parse_pdb_seqres_line(line)
                entries.append(pdb_seqres_dict)
        return entries


    @staticmethod
    def parse_pdb_entries(file_path: str, is_pqr_format: bool = False):
        &#34;&#34;&#34;
        Parse PDB file according to the spec provided at:
        https://www.wwpdb.org/documentation/file-format-content/format33/sect9.html#ATOM
        &#34;&#34;&#34;
        # Open the file and extract the individual lines.
        with open(file_path) as file:
            pdb_string = file.read()

        return PDBIO.parse_pdb_entries_from_string(pdb_string, is_pqr_format=is_pqr_format)

    @staticmethod
    def load_from_string(pdb_string: str,
                         is_pqr_format: bool = False,
                         pdb_id: Optional[str] = None) -&gt; List[Protein]:
        protein = Protein(pdb_id=pdb_id)
        models = []
        seqres = {}
        current_model = None
        current_chain: Optional[Chain] = None
        current_chain_id = None
        current_residue: Optional[Residue] = None
        current_residue_id = None

        entries = PDBIO.parse_pdb_entries_from_string(pdb_string, is_pqr_format=is_pqr_format)

        for entry in entries:
            record_name = entry[&#34;record_name&#34;]
            if record_name == &#34;SEQRES&#34;:
                chain_id = entry[&#34;chain_id&#34;]
                if chain_id not in seqres:
                    seqres[chain_id] = []
                seqres[chain_id].extend(entry[&#34;residues&#34;])
            elif record_name == &#34;MODEL&#34;:
                # Usually, the MODEL field will only be found in structures based on NMR.
                # We only use the first model in a file if provided.
                # There is nothing to do, so we
                pass
            elif record_name == &#34;ENDMDL&#34;:
                # Usually, the ENDMDL field will only be found in structures based on NMR.
                # it closes a corresponding MODEL field.
                # Since the end of the model is reached, no more entries should be parsed.
                break
            elif record_name == &#34;TER&#34;:
                # The TER field terminates the current chain.
                current_chain = None
                current_chain_id = None
            elif record_name == &#34;ATOM&#34; or record_name == &#34;HETATM&#34;:
                # If we switched chains, set the chain.
                if entry[&#34;chain_id&#34;] != current_chain_id:
                    current_chain_id = entry[&#34;chain_id&#34;]
                    if protein.has_chain(current_chain_id):
                        current_chain = protein.get_chain(current_chain_id)
                    else:
                        current_chain = protein.create_chain(current_chain_id)

                # Check if the residue exists
                residue_id = current_chain_id + entry[&#34;res_seq&#34;] + entry[&#34;icode&#34;]
                if residue_id != current_residue_id:
                    current_residue_id = residue_id
                    if record_name == &#34;ATOM&#34;:
                        # if entry[&#34;res_name&#34;] in ResidueTemplate.VALID_DNA_RESIDUES:
                        #     current_residue = current_chain.add_dna_residue(
                        #         residue_type=entry[&#34;res_name&#34;],
                        #         sequence_no=int(entry[&#34;res_seq&#34;]),
                        #         insertion_code=entry[&#34;icode&#34;]
                        #     )
                        # else:
                        current_residue = Residue(
                            residue_type=entry[&#34;res_name&#34;],
                            sequence_no=int(entry[&#34;res_seq&#34;]),
                            insertion_code=entry[&#34;icode&#34;],
                            chain=current_chain)
                        current_chain.add_residue(current_residue)
                    elif record_name == &#34;HETATM&#34;:
                        current_residue = Residue(
                            residue_type=entry[&#34;res_name&#34;],
                            sequence_no=int(entry[&#34;res_seq&#34;]),
                            insertion_code=entry[&#34;icode&#34;],
                            chain=current_chain)
                        current_chain.add_residue(current_residue)

                        # current_residue = current_chain.add_het_residue(
                        #     residue_type=entry[&#34;res_name&#34;],
                        #     sequence_no=int(entry[&#34;res_seq&#34;]),
                        #     insertion_code=entry[&#34;icode&#34;]
                        # )

                # Temporary fix need to see if anything breaks (For Evo eg. 2HH1 -&gt; HH12)
                # Fix atom naming
                if entry[&#34;atom_name&#34;][0].isnumeric():
                    entry[&#34;atom_name&#34;] = entry[&#34;atom_name&#34;][1:] + entry[&#34;atom_name&#34;][0]
                    if entry[&#34;element&#34;] != &#34;H&#34;:
                        print(0)
                    if entry[&#34;atom_name&#34;][0] == &#34;H&#34;:
                        entry[&#34;element&#34;] = &#34;H&#34;

                # Add the atom to the residue
                # if entry[&#34;alt_loc&#34;] == &#34;&#34;:
                #     atom_id = entry[&#34;atom_name&#34;]
                # else:
                #     atom_id = entry[&#34;atom_name&#34;] + &#34;_&#34; + entry[&#34;alt_loc&#34;]
                atom = Atom(
                    element=entry[&#34;element&#34;],
                    atom_type=entry[&#34;atom_name&#34;],
                    x=entry[&#34;x&#34;],
                    y=entry[&#34;y&#34;],
                    z=entry[&#34;z&#34;],

                    # Serial is dependent on the atom ordering,
                    # so it is not used in the Atom class
                    # pdb_serial=entry[&#34;serial&#34;],
                    alt_loc=entry[&#34;alt_loc&#34;],
                    occupancy=entry[&#34;occupancy&#34;],
                    temp_factor=entry[&#34;temp_factor&#34;],
                    assigned_charge=entry[&#34;assigned_charge&#34;],
                    calculated_charge=entry[&#34;calculated_charge&#34;],
                    radius=entry[&#34;radius&#34;],
                    is_hetero=(record_name == &#34;HETATM&#34;),

                    residue=current_residue
                )

                # current_residue.add_atom(atom_id, atom)
                current_residue.add_atom(atom.atom_type, atom)

        if seqres:
            for chain_id in seqres:
                if seqres[chain_id]:
                    protein.get_chain(chain_id).set_attribute(&#34;seqres&#34;, seqres[chain_id])

        # Housekeeping
        # protein.set_residue_indexing()

        return [protein]


    @staticmethod
    def load(file_path: str,
             is_pqr_format: bool = False,
             pdb_id: Optional[str] = None) -&gt; List[Protein]:
        &#34;&#34;&#34;
        Load a protein from a PDB file.

        Args:
            file_path (str): The path to the PDB file.
            is_pqr_format (bool): If the file is in PQR format.
            pdb_id (str): The PDB ID of the protein.

        Returns:
            List[Protein]: A list of proteins.
        &#34;&#34;&#34;

        # Open the file and extract the individual lines.
        with open(file_path) as file:
            pdb_string = file.read()

        return PDBIO.load_from_string(pdb_string, is_pqr_format=is_pqr_format, pdb_id=pdb_id)

    @staticmethod
    def save_to_string(protein: Protein,
                       is_pqr_format=False) -&gt; str:
        text_entries = []
        num_seqres = 0
        num_atoms = 0
        num_hetatoms = 0
        num_ter = 0
        serial = 1
        atom_entry = None

        for chain in protein.chains:
            for residue in chain.residues:
                for atom in residue.atoms:
                    if not atom.is_hetero:
                        atom_entry = {
                            &#34;element&#34;: atom.element,
                            &#34;atom_name&#34;: atom.atom_type,
                            &#34;alt_loc&#34;: atom.get_attribute(&#34;pdb_alt_loc&#34;),
                            &#34;res_name&#34;: residue.residue_type,
                            &#34;chain_id&#34;: chain.chain_id,
                            &#34;res_seq&#34;: str(residue.sequence_no),
                            &#34;icode&#34;: residue.insertion_code,
                            &#34;x&#34;: atom.x,
                            &#34;y&#34;: atom.y,
                            &#34;z&#34;: atom.z,
                            &#34;occupancy&#34;: atom.get_attribute(&#34;occupancy&#34;),
                            # &#34;temp_factor&#34;: atom._pdb_temp_factor if atom._pdb_temp_factor is not None else 0.0,
                            &#34;temp_factor&#34;: atom.get_attribute(&#34;temp_factor&#34;),
                            &#34;assigned_charge&#34;: atom.get_attribute(&#34;assigned_charge&#34;),
                            &#34;calculated_charge&#34;: atom.get_attribute(&#34;calculated_charge&#34;),
                            &#34;radius&#34;: atom.get_attribute(&#34;radius&#34;)
                        }
                        if not is_pqr_format:
                            text_entries.append(PDBIO.create_pdb_atom_line(atom_entry, serial))
                        else:
                            text_entries.append(PDBIO.create_pqr_atom_line(atom_entry, serial))

                        serial += 1
                        num_atoms += 1

            # TER entry
            if atom_entry is not None:
                text_entries.append(PDBIO.create_pdb_ter_line(serial,
                                                              atom_entry[&#34;res_name&#34;],
                                                              atom_entry[&#34;chain_id&#34;],
                                                              atom_entry[&#34;res_seq&#34;],
                                                              atom_entry[&#34;icode&#34;]))
                serial = serial + 1
                num_ter += 1

        for chain in protein.chains:
            for residue in chain.residues:
                # HETATM entries
                for atom in residue.atoms:
                    if atom.is_hetero:
                        atom_entry = {
                            &#34;element&#34;: atom.element,
                            &#34;atom_name&#34;: atom.atom_type,
                            &#34;alt_loc&#34;: atom.get_attribute(&#34;pdb_alt_loc&#34;),
                            &#34;res_name&#34;: residue.residue_type,
                            &#34;chain_id&#34;: chain.chain_id,
                            &#34;res_seq&#34;: str(residue.sequence_no),
                            &#34;icode&#34;: residue.insertion_code,
                            &#34;x&#34;: atom.x,
                            &#34;y&#34;: atom.y,
                            &#34;z&#34;: atom.z,
                            &#34;occupancy&#34;: atom.get_attribute(&#34;occupancy&#34;),
                            # &#34;temp_factor&#34;: atom._pdb_temp_factor if atom._pdb_temp_factor is not None else 0.0,
                            &#34;temp_factor&#34;: atom.get_attribute(&#34;temp_factor&#34;),
                            &#34;charge&#34;: atom.get_attribute(&#34;assigned_charge&#34;)
                        }
                        if not is_pqr_format:
                            text_entries.append(PDBIO.create_pdb_atom_line(atom_entry, serial, record_name=&#34;HETATM&#34;))
                        else:
                            text_entries.append(PDBIO.create_pqr_atom_line(atom_entry, serial, record_name=&#34;HETATM&#34;))

                        serial += 1
                        num_hetatoms += 1
            # Hetero residues have no TER records, so no need to write a termination code.

        # Bookkeeping records
        text_entries.append(PDBIO.create_pdb_master_line(num_atoms, num_hetatoms, num_ter, num_seqres=num_seqres))
        text_entries.append(&#34;END&#34;.ljust(80))

        return &#34;\n&#34;.join(text_entries)

    @staticmethod
    def save(protein: Protein,
             file_path: str,
             is_pqr_format=False) -&gt; None:

        pdb_string = PDBIO.save_to_string(protein, is_pqr_format=is_pqr_format)

        with open(file_path, &#34;w&#34;) as file:
            file.write(pdb_string)

    # TODO: from_pdb_text and to_pdb_text was added by Claudio
    # The intent is that one should parse proteins from text
    # without working with files. However, a lot of code copying
    # was made and it need to be reworked significantly.

    # @staticmethod
    # def from_pdb_text(lines) -&gt; List[Protein]:
    #     lines = lines.split(&#34;\n&#34;)
    #
    #     entries = []
    #     for line in lines:
    #         record_name = line[0:6].strip().upper()
    #         if record_name == &#34;ATOM&#34;:
    #             pdb_atom_dict = PDBIO.parse_pdb_atom_line(line)
    #             entries.append(pdb_atom_dict)
    #         elif record_name == &#34;HETATM&#34;:
    #             pdb_atom_dict = PDBIO.parse_pdb_atom_line(line)
    #             entries.append(pdb_atom_dict)
    #         elif record_name == &#34;TER&#34;:
    #             pdb_ter_dict = PDBIO.parse_pdb_ter_line(line)
    #             entries.append(pdb_ter_dict)
    #         elif record_name == &#34;MODEL&#34;:
    #             pdb_model_dict = PDBIO.parse_pdb_model_line(line)
    #             entries.append(pdb_model_dict)
    #         elif record_name == &#34;ENDMDL&#34;:
    #             pdb_end_model_dict = PDBIO.parse_pdb_end_model_line(line)
    #             entries.append(pdb_end_model_dict)
    #         elif record_name == &#34;SEQRES&#34;:
    #             pdb_seqres_dict = PDBIO.parse_pdb_seqres_line(line)
    #             entries.append(pdb_seqres_dict)
    #
    #     protein = Protein()
    #     models = []
    #     seqres = {}
    #     current_model = None
    #     current_chain: Optional[Chain] = None
    #     current_chain_id = None
    #     current_residue: Optional[Residue] = None
    #     current_residue_id = None
    #
    #     for entry in entries:
    #         record_name = entry[&#34;record_name&#34;]
    #         if record_name == &#34;SEQRES&#34;:
    #             chain_id = entry[&#34;chain_id&#34;]
    #             if chain_id not in seqres:
    #                 seqres[chain_id] = []
    #             seqres[chain_id].extend(entry[&#34;residues&#34;])
    #         elif record_name == &#34;MODEL&#34;:
    #             # Usually, the MODEL field will only be found in structures based on NMR.
    #             # We only use the first model in a file if provided.
    #             # There is nothing to do, so we
    #             pass
    #         elif record_name == &#34;ENDMDL&#34;:
    #             # Usually, the ENDMDL field will only be found in structures based on NMR.
    #             # it closes a corresponding MODEL field.
    #             # Since the end of the model is reached, no more entries should be parsed.
    #             break
    #         elif record_name == &#34;TER&#34;:
    #             # The TER field terminates the current chain.
    #             current_chain = None
    #             current_chain_id = None
    #         elif record_name == &#34;ATOM&#34; or record_name == &#34;HETATM&#34;:
    #             # If we switched chains, set the chain.
    #             if entry[&#34;chain_id&#34;] != current_chain_id:
    #                 current_chain_id = entry[&#34;chain_id&#34;]
    #                 if protein.has_chain(current_chain_id):
    #                     current_chain = protein.get_chain(current_chain_id)
    #                 else:
    #                     current_chain = protein.create_chain(current_chain_id)
    #
    #             # Check if the residue exists
    #             residue_id = current_chain_id + entry[&#34;res_seq&#34;] + entry[&#34;icode&#34;]
    #             if residue_id != current_residue_id:
    #                 current_residue_id = residue_id
    #                 if record_name == &#34;ATOM&#34;:
    #                     # if entry[&#34;res_name&#34;] in ResidueTemplate.VALID_DNA_RESIDUES:
    #                     #     current_residue = current_chain.add_dna_residue(
    #                     #         residue_type=entry[&#34;res_name&#34;],
    #                     #         sequence_no=int(entry[&#34;res_seq&#34;]),
    #                     #         insertion_code=entry[&#34;icode&#34;]
    #                     #     )
    #                     # else:
    #                     current_residue = Residue(
    #                         residue_type=entry[&#34;res_name&#34;],
    #                         sequence_no=int(entry[&#34;res_seq&#34;]),
    #                         insertion_code=entry[&#34;icode&#34;],
    #                         chain=current_chain)
    #                     current_chain.add_residue(current_residue)
    #                 elif record_name == &#34;HETATM&#34;:
    #                     current_residue = Residue(
    #                         residue_type=entry[&#34;res_name&#34;],
    #                         sequence_no=int(entry[&#34;res_seq&#34;]),
    #                         insertion_code=entry[&#34;icode&#34;],
    #                         chain=current_chain)
    #                     current_chain.add_residue(current_residue)
    #
    #                     # current_residue = current_chain.add_het_residue(
    #                     #     residue_type=entry[&#34;res_name&#34;],
    #                     #     sequence_no=int(entry[&#34;res_seq&#34;]),
    #                     #     insertion_code=entry[&#34;icode&#34;]
    #                     # )
    #
    #             # Temporary fix need to see if anything breaks (For Evo eg. 2HH1 -&gt; HH12)
    #             # Fix atom naming
    #             if entry[&#34;atom_name&#34;][0].isnumeric():
    #                 entry[&#34;atom_name&#34;] = entry[&#34;atom_name&#34;][1:] + entry[&#34;atom_name&#34;][0]
    #                 if entry[&#34;element&#34;] != &#34;H&#34;:
    #                     print(0)
    #                 if entry[&#34;atom_name&#34;][0] == &#34;H&#34;:
    #                     entry[&#34;element&#34;] = &#34;H&#34;
    #
    #             # Add the atom to the residue
    #             if entry[&#34;alt_loc&#34;] == &#34;&#34;:
    #                 atom_id = entry[&#34;atom_name&#34;]
    #             else:
    #                 atom_id = entry[&#34;atom_name&#34;] + &#34;_&#34; + entry[&#34;alt_loc&#34;]
    #             atom = Atom(
    #                 element=entry[&#34;element&#34;],
    #                 atom_type=entry[&#34;atom_name&#34;],
    #                 x=entry[&#34;x&#34;],
    #                 y=entry[&#34;y&#34;],
    #                 z=entry[&#34;z&#34;],
    #
    #                 # pdb_serial=entry[&#34;serial&#34;],
    #                 # pdb_alt_loc=entry[&#34;alt_loc&#34;],
    #                 # pdb_occupancy=entry[&#34;occupancy&#34;],
    #                 # pdb_temp_factor=entry[&#34;temp_factor&#34;],
    #                 # pdb_assigned_charge=entry[&#34;assigned_charge&#34;],
    #                 # pqr_calculated_charge=entry[&#34;calculated_charge&#34;],
    #                 # pqr_radius=entry[&#34;radius&#34;],
    #                 #
    #                 is_hetero=(record_name == &#34;HETATM&#34;),
    #
    #                 residue=current_residue
    #             )
    #             current_residue.add_atom(atom_id, atom)
    #
    #     # if seqres:
    #     #     for chain_id in seqres:
    #     #         if seqres[chain_id]:
    #     #             protein.chains[chain_id].sequence = seqres[chain_id]
    #
    #     # Housekeeping
    #     # protein.set_residue_indexing()
    #
    #     return [protein]

    # @staticmethod
    # def to_pdb_text(protein: Protein):
    #     text_entries = &#34;&#34;
    #     num_seqres = 0
    #     num_atoms = 0
    #     num_hetatoms = 0
    #     num_ter = 0
    #     serial = 1
    #
    #     for chain in protein.chains:
    #         for residue in chain.residues:
    #             for atom in residue.atoms:
    #                 if not atom.is_hetero:
    #                     atom_entry = {
    #                         &#34;element&#34;: atom.element,
    #                         &#34;atom_name&#34;: atom.atom_type,
    #                         &#34;alt_loc&#34;: atom.get_attribute(&#34;pdb_alt_loc&#34;),
    #                         &#34;res_name&#34;: residue.residue_type,
    #                         &#34;chain_id&#34;: chain.chain_id,
    #                         &#34;res_seq&#34;: str(residue.sequence_no),
    #                         &#34;icode&#34;: residue.insertion_code,
    #                         &#34;x&#34;: atom.x,
    #                         &#34;y&#34;: atom.y,
    #                         &#34;z&#34;: atom.z,
    #                         &#34;occupancy&#34;: atom.get_attribute(&#34;occupancy&#34;),
    #                         # &#34;temp_factor&#34;: atom._pdb_temp_factor if atom._pdb_temp_factor is not None else 0.0,
    #                         &#34;temp_factor&#34;: atom.get_attribute(&#34;temp_factor&#34;),
    #                         &#34;charge&#34;: atom.get_attribute(&#34;assigned_charge&#34;)
    #                     }
    #                     text_entries += PDBIO.create_pdb_atom_line(atom_entry, serial)
    #                     text_entries += &#34;\n&#34;
    #                     serial += 1
    #                     num_atoms += 1
    #
    #     # Bookkeeping records
    #     text_entries += PDBIO.create_pdb_master_line(num_atoms, num_hetatoms, num_ter, num_seqres=num_seqres)
    #     text_entries += &#34;END&#34;.ljust(80)
    #     text_entries += &#34;\n&#34;
    #
    #     return text_entries

    # @staticmethod
    # def save_to_pdb(file_path: str, protein):
    #     entries = []
    #
    #     num_seqres = 0
    #     num_atoms = 0
    #     num_hetatoms = 0
    #     num_ter = 0
    #     serial = 1
    #
    #     for chain in protein.chains:
    #         for residue in chain.residues:
    #             # ATOM entries
    #             for atom in residue.atoms:
    #                 if not atom.is_hetero:
    #                     atom_entry = {
    #                         &#34;element&#34;: atom.element,
    #                         &#34;atom_name&#34;: atom.atom_type,
    #                         &#34;alt_loc&#34;: atom._pdb_alt_loc,
    #                         &#34;res_name&#34;: residue.residue_type,
    #                         &#34;chain_id&#34;: chain.chain_id,
    #                         &#34;res_seq&#34;: str(residue._pdb_sequence_no),
    #                         &#34;icode&#34;: residue._pdb_insertion_code,
    #                         &#34;x&#34;: atom.x,
    #                         &#34;y&#34;: atom.y,
    #                         &#34;z&#34;: atom.z,
    #                         &#34;occupancy&#34;: atom._pdb_occupancy,
    #                         &#34;temp_factor&#34;: atom._pdb_temp_factor if atom._pdb_temp_factor is not None else 0.0,
    #                         &#34;charge&#34;: atom._pdb_assigned_charge
    #                     }
    #                     entries.append(PDBParser.create_pdb_atom_line(atom_entry, serial))
    #                     serial += 1
    #                     num_atoms += 1
    #
    #         # TER entry
    #         if chain.num_residues - chain.num_hetero_residues &gt; 0:
    #             entries.append(
    #                 PDBParser.create_pdb_ter_line(serial, atom_entry[&#34;res_name&#34;], chain.chain_id, atom_entry[&#34;res_seq&#34;],
    #                                               atom_entry[&#34;icode&#34;]))
    #             serial = serial + 1
    #             num_ter += 1
    #
    #     for chain in protein.chains:
    #         for residue in chain.residues:
    #             # HETATM entries
    #             for atom in residue.atoms:
    #                 if atom.is_hetero:
    #                     atom_entry = {
    #                         &#34;element&#34;: atom.element,
    #                         &#34;atom_name&#34;: atom.atom_type,
    #                         &#34;alt_loc&#34;: atom._pdb_alt_loc,
    #                         &#34;res_name&#34;: residue.residue_type,
    #                         &#34;chain_id&#34;: chain.chain_id,
    #                         &#34;res_seq&#34;: str(residue._pdb_sequence_no),
    #                         &#34;icode&#34;: residue._pdb_insertion_code,
    #                         &#34;x&#34;: atom.x,
    #                         &#34;y&#34;: atom.y,
    #                         &#34;z&#34;: atom.z,
    #                         &#34;occupancy&#34;: atom._pdb_occupancy,
    #                         &#34;temp_factor&#34;: atom._pdb_temp_factor if atom._pdb_temp_factor is not None else 0.0,
    #                         &#34;charge&#34;: atom._pdb_assigned_charge
    #                     }
    #                     entries.append(PDBParser.create_pdb_atom_line(atom_entry, serial, &#34;HETATM&#34;))
    #                     serial += 1
    #                     num_hetatoms += 1
    #
    #         # Hetero residues have no TER records, so no need to write a termination code.
    #
    #     # Bookkeeping records
    #     entries.append(PDBParser.create_pdb_master_line(num_atoms, num_hetatoms, num_ter, num_seqres=num_seqres))
    #     entries.append(&#34;END&#34;.ljust(80))
    #
    #     # Write file
    #     with open(file_path, &#34;w&#34;) as file:
    #         file.write(&#34;\n&#34;.join(entries))

    # @staticmethod
    # def load_from_pdb(file_path: str):
    #     entries = PDBParser.parse_pdb_entries(file_path)
    #
    #     protein = Protein()
    #     models = []
    #     seqres = {}
    #     current_model = None
    #     current_chain: Chain = None
    #     current_chain_id = None
    #     current_residue: Residue = None
    #     current_residue_id = None
    #
    #     for entry in entries:
    #         record_name = entry[&#34;record_name&#34;]
    #         if record_name == &#34;SEQRES&#34;:
    #             chain_id = entry[&#34;chain_id&#34;]
    #             if chain_id not in seqres:
    #                 seqres[chain_id] = []
    #             seqres[chain_id].extend(entry[&#34;residues&#34;])
    #         elif record_name == &#34;MODEL&#34;:
    #             # Usually, the MODEL field will only be found in structures based on NMR.
    #             # We only use the first model in a file if provided.
    #             # There is nothing to do, so we
    #             pass
    #         elif record_name == &#34;ENDMDL&#34;:
    #             # Usually, the ENDMDL field will only be found in structures based on NMR.
    #             # it closes a corresponding MODEL field.
    #             # Since the end of the model is reached, no more entries should be parsed.
    #             break
    #         elif record_name == &#34;TER&#34;:
    #             # The TER field terminates the current chain.
    #             current_chain = None
    #             current_chain_id = None
    #         elif record_name == &#34;ATOM&#34; or record_name == &#34;HETATM&#34;:
    #             # If we switched chains, set the chain.
    #             if entry[&#34;chain_id&#34;] != current_chain_id:
    #                 current_chain_id = entry[&#34;chain_id&#34;]
    #                 if current_chain_id in protein._chains:
    #                     current_chain = protein._chains[current_chain_id]
    #                 else:
    #                     current_chain = protein.create_chain(current_chain_id)
    #
    #             # Check if the residue exists
    #             residue_id = current_chain_id + entry[&#34;res_seq&#34;] + entry[&#34;icode&#34;]
    #             if residue_id != current_residue_id:
    #                 current_residue_id = residue_id
    #                 if record_name == &#34;ATOM&#34;:
    #                     # if entry[&#34;res_name&#34;] in ResidueTemplate.VALID_DNA_RESIDUES:
    #                     #     current_residue = current_chain.add_dna_residue(
    #                     #         residue_type=entry[&#34;res_name&#34;],
    #                     #         sequence_no=int(entry[&#34;res_seq&#34;]),
    #                     #         insertion_code=entry[&#34;icode&#34;]
    #                     #     )
    #                     # else:
    #                     current_residue = Residue(
    #                         residue_type=entry[&#34;res_name&#34;],
    #                         pdb_sequence_no=int(entry[&#34;res_seq&#34;]),
    #                         pdb_insertion_code=entry[&#34;icode&#34;],
    #                         chain=current_chain)
    #                     current_chain.add_residue(current_residue)
    #                 elif record_name == &#34;HETATM&#34;:
    #                     current_residue = Residue(
    #                         residue_type=entry[&#34;res_name&#34;],
    #                         pdb_sequence_no=int(entry[&#34;res_seq&#34;]),
    #                         pdb_insertion_code=entry[&#34;icode&#34;],
    #                         chain=current_chain)
    #                     current_chain.add_residue(current_residue)
    #
    #                     # current_residue = current_chain.add_het_residue(
    #                     #     residue_type=entry[&#34;res_name&#34;],
    #                     #     sequence_no=int(entry[&#34;res_seq&#34;]),
    #                     #     insertion_code=entry[&#34;icode&#34;]
    #                     # )
    #
    #             # Temporary fix need to see if anything breaks (For Evo eg. 2HH1 -&gt; HH12)
    #             # Fix atom naming
    #             if entry[&#34;atom_name&#34;][0].isnumeric():
    #                 entry[&#34;atom_name&#34;] = entry[&#34;atom_name&#34;][1:] + entry[&#34;atom_name&#34;][0]
    #                 if entry[&#34;element&#34;] != &#34;H&#34;:
    #                     print(0)
    #                 if entry[&#34;atom_name&#34;][0] == &#34;H&#34;:
    #                     entry[&#34;element&#34;] = &#34;H&#34;
    #
    #             # Add the atom to the residue
    #             if entry[&#34;alt_loc&#34;] == &#34;&#34;:
    #                 atom_id = entry[&#34;atom_name&#34;]
    #             else:
    #                 atom_id = entry[&#34;atom_name&#34;] + &#34;_&#34; + entry[&#34;alt_loc&#34;]
    #             atom = Atom(
    #                 element=entry[&#34;element&#34;],
    #                 atom_type=entry[&#34;atom_name&#34;],
    #                 x=entry[&#34;x&#34;],
    #                 y=entry[&#34;y&#34;],
    #                 z=entry[&#34;z&#34;],
    #
    #                 pdb_serial=entry[&#34;serial&#34;],
    #                 pdb_alt_loc=entry[&#34;alt_loc&#34;],
    #                 pdb_occupancy=entry[&#34;occupancy&#34;],
    #                 pdb_temp_factor=entry[&#34;temp_factor&#34;],
    #                 pdb_assigned_charge=entry[&#34;assigned_charge&#34;],
    #                 pqr_calculated_charge=entry[&#34;calculated_charge&#34;],
    #                 pqr_radius=entry[&#34;radius&#34;],
    #
    #                 is_hetero=(record_name == &#34;HETATM&#34;),
    #
    #                 residue=current_residue
    #             )
    #             current_residue.add_atom(atom_id, atom)
    #
    #     # if seqres:
    #     #     for chain_id in seqres:
    #     #         if seqres[chain_id]:
    #     #             protein.chains[chain_id].sequence = seqres[chain_id]
    #
    #     # Housekeeping
    #     protein.set_residue_indexing()
    #
    #     return protein</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="protkit.file_io.pdb_io.PDBIO.create_pdb_atom_line"><code class="name flex">
<span>def <span class="ident">create_pdb_atom_line</span></span>(<span>atom:Â Dict, serial:Â int, record_name='ATOM') â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a ATOM or HETATM line for a PDB file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>atom</code></strong> :&ensp;<code>Dict</code></dt>
<dd>The atom information.</dd>
<dt><strong><code>serial</code></strong> :&ensp;<code>int</code></dt>
<dd>The serial number of the atom.</dd>
<dt><strong><code>record_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The record name, should be ATOM or HETATM.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The ATOM or HETATM line.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_pdb_atom_line(atom: Dict, serial: int, record_name=&#34;ATOM&#34;) -&gt; str:
    &#34;&#34;&#34;
    Creates a ATOM or HETATM line for a PDB file.

    Args:
        atom (Dict): The atom information.
        serial (int): The serial number of the atom.
        record_name (str): The record name, should be ATOM or HETATM.

    Returns:
        str: The ATOM or HETATM line.
    &#34;&#34;&#34;
    text = record_name.ljust(6)
    text += str(serial).rjust(5) + &#34; &#34;

    # The PDB spec says that if the element has two characters, e.g. Fe (iron)
    # it should start at the position 13, otherwise it should start at position 14.
    # This seems a little problematic, as some atoms could use 4 characters
    # for example, HG11. The implementation here is consistent with observed PDBs
    # from the RCSB.
    if len(atom[&#34;element&#34;]) == 2 or len(atom[&#34;atom_name&#34;]) == 4:
        text += atom[&#34;atom_name&#34;].ljust(4)
    else:
        text += &#34; &#34; + atom[&#34;atom_name&#34;].ljust(3)
    text += (&#34;&#34; if atom[&#34;alt_loc&#34;] is None else atom[&#34;alt_loc&#34;]).ljust(1)
    text += atom[&#34;res_name&#34;].rjust(3) + &#34; &#34;
    text += atom[&#34;chain_id&#34;]
    text += atom[&#34;res_seq&#34;].rjust(4)
    text += atom[&#34;icode&#34;].ljust(1) + &#34;   &#34;
    text += f&#39;{atom[&#34;x&#34;]:8.3f}&#39;
    text += f&#39;{atom[&#34;y&#34;]:8.3f}&#39;
    text += f&#39;{atom[&#34;z&#34;]:8.3f}&#39;
    text += f&#39;{1.0 if atom[&#34;occupancy&#34;] is None else atom[&#34;occupancy&#34;]:6.2f}&#39;
    text += f&#39;{0.0 if atom[&#34;temp_factor&#34;] is None else atom[&#34;temp_factor&#34;]:6.2f}&#39;
    text += &#34;&#34;.ljust(10)
    text += atom[&#34;element&#34;].rjust(2)
    text += (&#34;&#34; if atom[&#34;assigned_charge&#34;] is None else atom[&#34;assigned_charge&#34;]).rjust(2)
    return text</code></pre>
</details>
</dd>
<dt id="protkit.file_io.pdb_io.PDBIO.create_pdb_end_model_line"><code class="name flex">
<span>def <span class="ident">create_pdb_end_model_line</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a ENDMDL (end model) line for a PDB file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_pdb_end_model_line():
    &#34;&#34;&#34;
    Creates a ENDMDL (end model) line for a PDB file.
    &#34;&#34;&#34;
    return &#34;ENDMDL&#34;.ljust(80)</code></pre>
</details>
</dd>
<dt id="protkit.file_io.pdb_io.PDBIO.create_pdb_master_line"><code class="name flex">
<span>def <span class="ident">create_pdb_master_line</span></span>(<span>num_atoms, num_hetatoms, num_ter, num_remark=0, num_het=0, num_helix=0, num_sheet=0, num_site=0, num_trans=0, num_conect=0, num_seqres=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a MASTER (recordkeeping) line for a PDB file.</p>
<h2 id="columns-data-type-field-definition">Columns
Data Type
Field
Definition</h2>
<p>1 -
6
Record name
"MASTER"
11 - 15
Integer
numRemark
Number of REMARK records
16 - 20
Integer
"0"
21 - 25
Integer
numHet
Number of HET records
26 - 30
Integer
numHelix
Number of HELIX records
31 - 35
Integer
numSheet
Number of SHEET records
36 - 40
Integer
numTurn
deprecated
41 - 45
Integer
numSite
Number of SITE records
46 - 50
Integer
numXform
Number of coordinate transformation
records
(ORIGX+SCALE+MTRIX)
51 - 55
Integer
numCoord
Number of atomic coordinate records
records (ATOM+HETATM)
56 - 60
Integer
numTer
Number of TER records
61 - 65
Integer
numConect
Number of CONECT records
66 - 70
Integer
numSeq
Number of SEQRES records</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_pdb_master_line(num_atoms, num_hetatoms, num_ter, num_remark=0, num_het=0, num_helix=0, num_sheet=0,
                           num_site=0, num_trans=0, num_conect=0, num_seqres=0):
    &#34;&#34;&#34;
    Creates a MASTER (recordkeeping) line for a PDB file.

    COLUMNS         DATA TYPE     FIELD          DEFINITION
    ----------------------------------------------------------------------------------
     1 -  6         Record name   &#34;MASTER&#34;
    11 - 15         Integer       numRemark      Number of REMARK records
    16 - 20         Integer       &#34;0&#34;
    21 - 25         Integer       numHet         Number of HET records
    26 - 30         Integer       numHelix       Number of HELIX records
    31 - 35         Integer       numSheet       Number of SHEET records
    36 - 40         Integer       numTurn        deprecated
    41 - 45         Integer       numSite        Number of SITE records
    46 - 50         Integer       numXform       Number of coordinate transformation
                                                 records  (ORIGX+SCALE+MTRIX)
    51 - 55         Integer       numCoord       Number of atomic coordinate records
                                                 records (ATOM+HETATM)
    56 - 60         Integer       numTer         Number of TER records
    61 - 65         Integer       numConect      Number of CONECT records
    66 - 70         Integer       numSeq         Number of SEQRES records
    &#34;&#34;&#34;

    entries = [
        &#34;MASTER&#34;.ljust(10),
        str(num_remark).rjust(5),
        &#34;0&#34;.rjust(5),
        str(num_het).rjust(5),
        str(num_helix).rjust(5),
        str(num_sheet).rjust(5),
        &#34;0&#34;.rjust(5),
        str(num_site).rjust(5),
        str(num_trans).rjust(5),
        str(num_atoms + num_hetatoms).rjust(5),
        str(num_ter).rjust(5),
        str(num_conect).rjust(5),
        str(num_seqres).rjust(5),
        &#34;&#34;.ljust(10)
    ]

    return &#34;&#34;.join(entries)</code></pre>
</details>
</dd>
<dt id="protkit.file_io.pdb_io.PDBIO.create_pdb_model_line"><code class="name flex">
<span>def <span class="ident">create_pdb_model_line</span></span>(<span>serial:Â int)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a MODEL (start model) line for a PDB file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_pdb_model_line(serial: int):
    &#34;&#34;&#34;
    Creates a MODEL (start model) line for a PDB file.
    &#34;&#34;&#34;
    return &#34;MODEL&#34;.ljust(10) + str(serial).rjust(4) + &#34;&#34;.ljust(66)</code></pre>
</details>
</dd>
<dt id="protkit.file_io.pdb_io.PDBIO.create_pdb_ter_line"><code class="name flex">
<span>def <span class="ident">create_pdb_ter_line</span></span>(<span>serial, res_name, chain_id, res_seq, icode)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a TER (chain termination) line for a PDB file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_pdb_ter_line(serial, res_name, chain_id, res_seq, icode):
    &#34;&#34;&#34;
    Creates a TER (chain termination) line for a PDB file.
    &#34;&#34;&#34;
    text = &#34;TER&#34;.ljust(6)
    text += str(serial).rjust(5) + &#34;      &#34;
    text += res_name.rjust(3) + &#34; &#34;
    text += chain_id
    text += res_seq.rjust(4)
    text += icode.ljust(1)

    return text.ljust(80)</code></pre>
</details>
</dd>
<dt id="protkit.file_io.pdb_io.PDBIO.create_pqr_atom_line"><code class="name flex">
<span>def <span class="ident">create_pqr_atom_line</span></span>(<span>atom:Â Dict, serial:Â int, record_name='ATOM') â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a ATOM or HETATM line for a PQR file.</p>
<p>The PQR line is similar to the PDB ATOM line, but with additional fields
for atomic charge and radius. The occupancy, temperature factor,
charge and element fields from the PDB file are not used in the PQR file.</p>
<p>See: <a href="https://pdb2pqr.readthedocs.io/en/latest/formats/pqr.html">https://pdb2pqr.readthedocs.io/en/latest/formats/pqr.html</a>
The order of fields in a PQR file is as follows:
Field_name Atom_number Atom_name Residue_name Chain_ID Residue_number
X Y Z Charge Radius</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>atom</code></strong> :&ensp;<code>Dict</code></dt>
<dd>The atom information.</dd>
<dt><strong><code>serial</code></strong> :&ensp;<code>int</code></dt>
<dd>The serial number of the atom.</dd>
<dt><strong><code>record_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The record name, should be ATOM or HETATM.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The PQR ATOM or HETATM line.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_pqr_atom_line(atom: Dict, serial: int, record_name=&#34;ATOM&#34;) -&gt; str:
    &#34;&#34;&#34;
    Creates a ATOM or HETATM line for a PQR file.

    The PQR line is similar to the PDB ATOM line, but with additional fields
    for atomic charge and radius. The occupancy, temperature factor,
    charge and element fields from the PDB file are not used in the PQR file.

    See: https://pdb2pqr.readthedocs.io/en/latest/formats/pqr.html
    The order of fields in a PQR file is as follows:
    Field_name Atom_number Atom_name Residue_name Chain_ID Residue_number
    X Y Z Charge Radius

    Args:
        atom (Dict): The atom information.
        serial (int): The serial number of the atom.
        record_name (str): The record name, should be ATOM or HETATM.

    Returns:
        str: The PQR ATOM or HETATM line.
    &#34;&#34;&#34;
    text = record_name.ljust(6)
    text += str(serial).rjust(5) + &#34; &#34;

    # The PDB spec says that if the element has two characters, e.g. Fe (iron)
    # it should start at the position 13, otherwise it should start at position 14.
    # This seems a little problematic, as some atoms could use 4 characters
    # for example, HG11. The implementation here is consistent with observed PDBs
    # from the RCSB.
    if len(atom[&#34;element&#34;]) == 2 or len(atom[&#34;atom_name&#34;]) == 4:
        text += atom[&#34;atom_name&#34;].ljust(4)
    else:
        text += &#34; &#34; + atom[&#34;atom_name&#34;].ljust(3)
    text += (&#34;&#34; if atom[&#34;alt_loc&#34;] is None else atom[&#34;alt_loc&#34;]).ljust(1)
    text += atom[&#34;res_name&#34;].rjust(3) + &#34; &#34;
    text += atom[&#34;chain_id&#34;]
    text += atom[&#34;res_seq&#34;].rjust(4)
    text += atom[&#34;icode&#34;].ljust(1) + &#34;   &#34;
    text += f&#39;{atom[&#34;x&#34;]:8.3f}&#39;
    text += f&#39;{atom[&#34;y&#34;]:8.3f}&#39;
    text += f&#39;{atom[&#34;z&#34;]:8.3f}&#39;
    text += f&#39;{0.0 if atom[&#34;calculated_charge&#34;] is None else atom[&#34;calculated_charge&#34;]:8.4f}&#39;
    text += f&#39;{0.0 if atom[&#34;radius&#34;] is None else atom[&#34;radius&#34;]:7.4f}&#39;
    # text += f&#39;{1.0 if atom[&#34;occupancy&#34;] is None else atom[&#34;occupancy&#34;]:6.2f}&#39;
    # text += f&#39;{0.0 if atom[&#34;temp_factor&#34;] is None else atom[&#34;temp_factor&#34;]:6.2f}&#39;
    # text += &#34;&#34;.ljust(10)
    # text += atom[&#34;element&#34;].rjust(2)
    # text += (&#34;&#34; if atom[&#34;charge&#34;] is None else atom[&#34;charge&#34;]).rjust(2)

    return text</code></pre>
</details>
</dd>
<dt id="protkit.file_io.pdb_io.PDBIO.create_seqres_line"><code class="name flex">
<span>def <span class="ident">create_seqres_line</span></span>(<span>line_no, chain_id, num_residues, residues)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a SEQRES (sequence) line for a PDB file.</p>
<p>1 -
6
Record name
"SEQRES"
8 - 10
Integer
serNum
Serial number of the SEQRES record for
the
current
chain. Starts at 1 and increments
by one
each line. Reset to 1 for each chain.
12
Character
chainID
Chain identifier. This may be any single
legal
character, including a blank which
is used if there is only one chain.
14 - 17
Integer
numRes
Number of residues in the chain.
This
value is repeated on every record.
20 - 22
Residue name
resName
Residue name.
24 - 26
Residue name
resName
Residue name.
28 - 30
Residue name
resName
Residue name.
32 - 34
Residue name
resName
Residue name.
36 - 38
Residue name
resName
Residue name.
40 - 42
Residue name
resName
Residue name.
44 - 46
Residue name
resName
Residue name.
48 - 50
Residue name
resName
Residue name.
52 - 54
Residue name
resName
Residue name.
56 - 58
Residue name
resName
Residue name.
60 - 62
Residue name
resName
Residue name.
64 - 66
Residue name
resName
Residue name.
68 - 70
Residue name
resName
Residue name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_seqres_line(line_no, chain_id, num_residues, residues):
    &#34;&#34;&#34;
    Creates a SEQRES (sequence) line for a PDB file.

     1 -  6        Record name    &#34;SEQRES&#34;
     8 - 10        Integer        serNum       Serial number of the SEQRES record for  the
                                               current  chain. Starts at 1 and increments
                                               by one  each line. Reset to 1 for each chain.
    12             Character      chainID      Chain identifier. This may be any single
                                               legal  character, including a blank which
                                               is used if there is only one chain.
    14 - 17        Integer        numRes       Number of residues in the chain.
                                               This  value is repeated on every record.
    20 - 22        Residue name   resName      Residue name.
    24 - 26        Residue name   resName      Residue name.
    28 - 30        Residue name   resName      Residue name.
    32 - 34        Residue name   resName      Residue name.
    36 - 38        Residue name   resName      Residue name.
    40 - 42        Residue name   resName      Residue name.
    44 - 46        Residue name   resName      Residue name.
    48 - 50        Residue name   resName      Residue name.
    52 - 54        Residue name   resName      Residue name.
    56 - 58        Residue name   resName      Residue name.
    60 - 62        Residue name   resName      Residue name.
    64 - 66        Residue name   resName      Residue name.
    68 - 70        Residue name   resName      Residue name.
    &#34;&#34;&#34;
    entries = [
        &#34;SEQRES &#34;,
        str(line_no).rjust(3) + &#34; &#34;,
        chain_id + &#34; &#34;,
        str(num_residues).rjust(4) + &#34;  &#34;
    ]
    for residue in residues:
        entries.append(residue[&#34;residue&#34;].rjust(3) + &#34; &#34;)
    return &#34;&#34;.join(entries).ljust(80)</code></pre>
</details>
</dd>
<dt id="protkit.file_io.pdb_io.PDBIO.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>file_path:Â str, is_pqr_format:Â boolÂ =Â False, pdb_id:Â Optional[str]Â =Â None) â€‘>Â List[<a title="protkit.structure.protein.Protein" href="../structure/protein.html#protkit.structure.protein.Protein">Protein</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Load a protein from a PDB file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the PDB file.</dd>
<dt><strong><code>is_pqr_format</code></strong> :&ensp;<code>bool</code></dt>
<dd>If the file is in PQR format.</dd>
<dt><strong><code>pdb_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The PDB ID of the protein.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[Protein]</code></dt>
<dd>A list of proteins.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(file_path: str,
         is_pqr_format: bool = False,
         pdb_id: Optional[str] = None) -&gt; List[Protein]:
    &#34;&#34;&#34;
    Load a protein from a PDB file.

    Args:
        file_path (str): The path to the PDB file.
        is_pqr_format (bool): If the file is in PQR format.
        pdb_id (str): The PDB ID of the protein.

    Returns:
        List[Protein]: A list of proteins.
    &#34;&#34;&#34;

    # Open the file and extract the individual lines.
    with open(file_path) as file:
        pdb_string = file.read()

    return PDBIO.load_from_string(pdb_string, is_pqr_format=is_pqr_format, pdb_id=pdb_id)</code></pre>
</details>
</dd>
<dt id="protkit.file_io.pdb_io.PDBIO.load_from_string"><code class="name flex">
<span>def <span class="ident">load_from_string</span></span>(<span>pdb_string:Â str, is_pqr_format:Â boolÂ =Â False, pdb_id:Â Optional[str]Â =Â None) â€‘>Â List[<a title="protkit.structure.protein.Protein" href="../structure/protein.html#protkit.structure.protein.Protein">Protein</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load_from_string(pdb_string: str,
                     is_pqr_format: bool = False,
                     pdb_id: Optional[str] = None) -&gt; List[Protein]:
    protein = Protein(pdb_id=pdb_id)
    models = []
    seqres = {}
    current_model = None
    current_chain: Optional[Chain] = None
    current_chain_id = None
    current_residue: Optional[Residue] = None
    current_residue_id = None

    entries = PDBIO.parse_pdb_entries_from_string(pdb_string, is_pqr_format=is_pqr_format)

    for entry in entries:
        record_name = entry[&#34;record_name&#34;]
        if record_name == &#34;SEQRES&#34;:
            chain_id = entry[&#34;chain_id&#34;]
            if chain_id not in seqres:
                seqres[chain_id] = []
            seqres[chain_id].extend(entry[&#34;residues&#34;])
        elif record_name == &#34;MODEL&#34;:
            # Usually, the MODEL field will only be found in structures based on NMR.
            # We only use the first model in a file if provided.
            # There is nothing to do, so we
            pass
        elif record_name == &#34;ENDMDL&#34;:
            # Usually, the ENDMDL field will only be found in structures based on NMR.
            # it closes a corresponding MODEL field.
            # Since the end of the model is reached, no more entries should be parsed.
            break
        elif record_name == &#34;TER&#34;:
            # The TER field terminates the current chain.
            current_chain = None
            current_chain_id = None
        elif record_name == &#34;ATOM&#34; or record_name == &#34;HETATM&#34;:
            # If we switched chains, set the chain.
            if entry[&#34;chain_id&#34;] != current_chain_id:
                current_chain_id = entry[&#34;chain_id&#34;]
                if protein.has_chain(current_chain_id):
                    current_chain = protein.get_chain(current_chain_id)
                else:
                    current_chain = protein.create_chain(current_chain_id)

            # Check if the residue exists
            residue_id = current_chain_id + entry[&#34;res_seq&#34;] + entry[&#34;icode&#34;]
            if residue_id != current_residue_id:
                current_residue_id = residue_id
                if record_name == &#34;ATOM&#34;:
                    # if entry[&#34;res_name&#34;] in ResidueTemplate.VALID_DNA_RESIDUES:
                    #     current_residue = current_chain.add_dna_residue(
                    #         residue_type=entry[&#34;res_name&#34;],
                    #         sequence_no=int(entry[&#34;res_seq&#34;]),
                    #         insertion_code=entry[&#34;icode&#34;]
                    #     )
                    # else:
                    current_residue = Residue(
                        residue_type=entry[&#34;res_name&#34;],
                        sequence_no=int(entry[&#34;res_seq&#34;]),
                        insertion_code=entry[&#34;icode&#34;],
                        chain=current_chain)
                    current_chain.add_residue(current_residue)
                elif record_name == &#34;HETATM&#34;:
                    current_residue = Residue(
                        residue_type=entry[&#34;res_name&#34;],
                        sequence_no=int(entry[&#34;res_seq&#34;]),
                        insertion_code=entry[&#34;icode&#34;],
                        chain=current_chain)
                    current_chain.add_residue(current_residue)

                    # current_residue = current_chain.add_het_residue(
                    #     residue_type=entry[&#34;res_name&#34;],
                    #     sequence_no=int(entry[&#34;res_seq&#34;]),
                    #     insertion_code=entry[&#34;icode&#34;]
                    # )

            # Temporary fix need to see if anything breaks (For Evo eg. 2HH1 -&gt; HH12)
            # Fix atom naming
            if entry[&#34;atom_name&#34;][0].isnumeric():
                entry[&#34;atom_name&#34;] = entry[&#34;atom_name&#34;][1:] + entry[&#34;atom_name&#34;][0]
                if entry[&#34;element&#34;] != &#34;H&#34;:
                    print(0)
                if entry[&#34;atom_name&#34;][0] == &#34;H&#34;:
                    entry[&#34;element&#34;] = &#34;H&#34;

            # Add the atom to the residue
            # if entry[&#34;alt_loc&#34;] == &#34;&#34;:
            #     atom_id = entry[&#34;atom_name&#34;]
            # else:
            #     atom_id = entry[&#34;atom_name&#34;] + &#34;_&#34; + entry[&#34;alt_loc&#34;]
            atom = Atom(
                element=entry[&#34;element&#34;],
                atom_type=entry[&#34;atom_name&#34;],
                x=entry[&#34;x&#34;],
                y=entry[&#34;y&#34;],
                z=entry[&#34;z&#34;],

                # Serial is dependent on the atom ordering,
                # so it is not used in the Atom class
                # pdb_serial=entry[&#34;serial&#34;],
                alt_loc=entry[&#34;alt_loc&#34;],
                occupancy=entry[&#34;occupancy&#34;],
                temp_factor=entry[&#34;temp_factor&#34;],
                assigned_charge=entry[&#34;assigned_charge&#34;],
                calculated_charge=entry[&#34;calculated_charge&#34;],
                radius=entry[&#34;radius&#34;],
                is_hetero=(record_name == &#34;HETATM&#34;),

                residue=current_residue
            )

            # current_residue.add_atom(atom_id, atom)
            current_residue.add_atom(atom.atom_type, atom)

    if seqres:
        for chain_id in seqres:
            if seqres[chain_id]:
                protein.get_chain(chain_id).set_attribute(&#34;seqres&#34;, seqres[chain_id])

    # Housekeeping
    # protein.set_residue_indexing()

    return [protein]</code></pre>
</details>
</dd>
<dt id="protkit.file_io.pdb_io.PDBIO.parse_pdb_atom_line"><code class="name flex">
<span>def <span class="ident">parse_pdb_atom_line</span></span>(<span>line, is_pqr_format:Â boolÂ =Â False)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a ATOM (individual atom) or HETATM (hetero atom) line from a PDB file.</p>
<h2 id="columns-data-type-field-definition">Columns
Data
Type
Field
Definition</h2>
<p>1 -
6
Record name
"ATOM
"
7 - 11
Integer
serial
Atom
serial number.
13 - 16
Atom
name
Atom name.
17
Character
altLoc
Alternate location indicator.
18 - 20
Residue name
resName
Residue name.
22
Character
chainID
Chain identifier.
23 - 26
Integer
resSeq
Residue sequence number.
27
AChar
iCode
Code for insertion of residues.
31 - 38
Real(8.3)
x
Orthogonal coordinates for X in Angstroms.
39 - 46
Real(8.3)
y
Orthogonal coordinates for Y in Angstroms.
47 - 54
Real(8.3)
z
Orthogonal coordinates for Z in Angstroms.
55 - 60
Real(6.2)
occupancy
Occupancy.
61 - 66
Real(6.2)
tempFactor
Temperature
factor.
77 - 78
LString(2)
element
Element symbol, right-justified.
79 - 80
LString(2)
charge
Charge
on the atom.`</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse_pdb_atom_line(line, is_pqr_format: bool = False):
    &#34;&#34;&#34;
    Parse a ATOM (individual atom) or HETATM (hetero atom) line from a PDB file.

    COLUMNS        DATA  TYPE    FIELD        DEFINITION
    -------------------------------------------------------------------------------------
     1 -  6        Record name   &#34;ATOM  &#34;
     7 - 11        Integer       serial       Atom  serial number.
    13 - 16        Atom          name         Atom name.
    17             Character     altLoc       Alternate location indicator.
    18 - 20        Residue name  resName      Residue name.
    22             Character     chainID      Chain identifier.
    23 - 26        Integer       resSeq       Residue sequence number.
    27             AChar         iCode        Code for insertion of residues.
    31 - 38        Real(8.3)     x            Orthogonal coordinates for X in Angstroms.
    39 - 46        Real(8.3)     y            Orthogonal coordinates for Y in Angstroms.
    47 - 54        Real(8.3)     z            Orthogonal coordinates for Z in Angstroms.
    55 - 60        Real(6.2)     occupancy    Occupancy.
    61 - 66        Real(6.2)     tempFactor   Temperature  factor.
    77 - 78        LString(2)    element      Element symbol, right-justified.
    79 - 80        LString(2)    charge       Charge  on the atom.`
    &#34;&#34;&#34;
    if not is_pqr_format:
        pdb_atom_dict = {
            &#34;record_name&#34;: line[0:6].strip().upper(),
            &#34;serial&#34;: line[6:11].strip(),
            # Open space
            &#34;atom_name&#34;: line[12:16].strip(),
            &#34;alt_loc&#34;: line[16].strip(),
            &#34;res_name&#34;: line[17:20].strip(),
            # Open space
            &#34;chain_id&#34;: line[21].strip(),
            &#34;res_seq&#34;: line[22:26].strip(),
            &#34;icode&#34;: line[26].strip(),
            # 3x Open space
            &#34;x&#34;: float(line[30:38]),
            &#34;y&#34;: float(line[38:46]),
            &#34;z&#34;: float(line[46:54]),
            &#34;occupancy&#34;: float(line[54:60]),
            # &#34;temp_factor&#34;: None,
            &#34;temp_factor&#34;: float(line[60:66]),
            # 66 - 75?
            &#34;element&#34;: line[76:78].strip(),
            &#34;assigned_charge&#34;: line[78:80].strip(),
            &#34;calculated_charge&#34;: None,
            &#34;radius&#34;: None
        }
    else:
        pdb_atom_dict = {
            &#34;record_name&#34;: line[0:6].strip().upper(),
            &#34;serial&#34;: line[6:11].strip(),
            # Open space
            &#34;atom_name&#34;: line[12:16].strip(),
            &#34;alt_loc&#34;: line[16].strip(),
            &#34;res_name&#34;: line[17:20].strip(),
            # Open space
            &#34;chain_id&#34;: line[21].strip(),
            &#34;res_seq&#34;: line[22:26].strip(),
            &#34;icode&#34;: line[26].strip(),
            # 3x Open space
            &#34;x&#34;: float(line[30:38]),
            &#34;y&#34;: float(line[38:46]),
            &#34;z&#34;: float(line[46:54]),

            &#34;occupancy&#34;: 1.0,
            &#34;temp_factor&#34;: None,

            &#34;element&#34;: line[76:78].strip(),
            &#34;assigned_charge&#34;: None,
            &#34;calculated_charge&#34;: float(line[54:62]),
            &#34;radius&#34;: float(line[62:70])
        }
    return pdb_atom_dict</code></pre>
</details>
</dd>
<dt id="protkit.file_io.pdb_io.PDBIO.parse_pdb_end_model_line"><code class="name flex">
<span>def <span class="ident">parse_pdb_end_model_line</span></span>(<span>line:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a ENDMDL (end model) line from a PDB file.</p>
<h2 id="columns-data-type-field-definition">Columns
Data
Type
Field
Definition</h2>
<p>1 - 6
Record name
"ENDMDL"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse_pdb_end_model_line(line: str):
    &#34;&#34;&#34;
    Parse a ENDMDL (end model) line from a PDB file.

    COLUMNS       DATA  TYPE     FIELD        DEFINITION
    ------------------------------------------------------------------
    1 - 6         Record name   &#34;ENDMDL&#34;

    &#34;&#34;&#34;
    pdb_end_model_dict = {
        &#34;record_name&#34;: &#34;ENDMDL&#34;
    }

    return pdb_end_model_dict</code></pre>
</details>
</dd>
<dt id="protkit.file_io.pdb_io.PDBIO.parse_pdb_entries"><code class="name flex">
<span>def <span class="ident">parse_pdb_entries</span></span>(<span>file_path:Â str, is_pqr_format:Â boolÂ =Â False)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse PDB file according to the spec provided at:
<a href="https://www.wwpdb.org/documentation/file-format-content/format33/sect9.html#ATOM">https://www.wwpdb.org/documentation/file-format-content/format33/sect9.html#ATOM</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse_pdb_entries(file_path: str, is_pqr_format: bool = False):
    &#34;&#34;&#34;
    Parse PDB file according to the spec provided at:
    https://www.wwpdb.org/documentation/file-format-content/format33/sect9.html#ATOM
    &#34;&#34;&#34;
    # Open the file and extract the individual lines.
    with open(file_path) as file:
        pdb_string = file.read()

    return PDBIO.parse_pdb_entries_from_string(pdb_string, is_pqr_format=is_pqr_format)</code></pre>
</details>
</dd>
<dt id="protkit.file_io.pdb_io.PDBIO.parse_pdb_entries_from_string"><code class="name flex">
<span>def <span class="ident">parse_pdb_entries_from_string</span></span>(<span>pdb_string:Â str, is_pqr_format:Â boolÂ =Â False)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a PDB file in string format into a list of entries.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pdb_string</code></strong> :&ensp;<code>str</code></dt>
<dd>The PDB file as a string.</dd>
<dt><strong><code>is_pqr_format</code></strong> :&ensp;<code>bool</code></dt>
<dd>If the file is in PQR format.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[Dict]</code></dt>
<dd>A list of parsed entries.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse_pdb_entries_from_string(pdb_string: str, is_pqr_format: bool = False):
    &#34;&#34;&#34;
    Parse a PDB file in string format into a list of entries.

    Args:
        pdb_string (str): The PDB file as a string.
        is_pqr_format (bool): If the file is in PQR format.

    Returns:
        List[Dict]: A list of parsed entries.
    &#34;&#34;&#34;

    # Split the string into lines
    lines = pdb_string.split(&#34;\n&#34;)

    # Parse every line into dictionary information
    entries = []
    for line in lines:
        record_name = line[0:6].strip().upper()
        if record_name == &#34;ATOM&#34;:
            pdb_atom_dict = PDBIO.parse_pdb_atom_line(line, is_pqr_format=is_pqr_format)
            entries.append(pdb_atom_dict)
        elif record_name == &#34;HETATM&#34;:
            pdb_atom_dict = PDBIO.parse_pdb_atom_line(line, is_pqr_format=is_pqr_format)
            entries.append(pdb_atom_dict)
        elif record_name == &#34;TER&#34;:
            pdb_ter_dict = PDBIO.parse_pdb_ter_line(line)
            entries.append(pdb_ter_dict)
        elif record_name == &#34;MODEL&#34;:
            pdb_model_dict = PDBIO.parse_pdb_model_line(line)
            entries.append(pdb_model_dict)
        elif record_name == &#34;ENDMDL&#34;:
            pdb_end_model_dict = PDBIO.parse_pdb_end_model_line(line)
            entries.append(pdb_end_model_dict)
        elif record_name == &#34;SEQRES&#34;:
            pdb_seqres_dict = PDBIO.parse_pdb_seqres_line(line)
            entries.append(pdb_seqres_dict)
    return entries</code></pre>
</details>
</dd>
<dt id="protkit.file_io.pdb_io.PDBIO.parse_pdb_model_line"><code class="name flex">
<span>def <span class="ident">parse_pdb_model_line</span></span>(<span>line:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a MODEL (start model) line from a PDB file.</p>
<h2 id="columns-data-type-field-definition">Columns
Data
Type
Field
Definition</h2>
<p>1 -
6
Record name
"MODEL "
11 - 14
Integer
serial
Model serial number.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse_pdb_model_line(line: str):
    &#34;&#34;&#34;
    Parse a MODEL (start model) line from a PDB file.

    COLUMNS        DATA  TYPE    FIELD          DEFINITION
    ---------------------------------------------------------------------------------------
     1 -  6        Record name   &#34;MODEL &#34;
    11 - 14        Integer       serial         Model serial number.
    &#34;&#34;&#34;
    pdb_model_dict = {
        &#34;record_name&#34;: &#34;MODEL&#34;,
        &#34;serial&#34;: line[10:14]
    }

    return pdb_model_dict</code></pre>
</details>
</dd>
<dt id="protkit.file_io.pdb_io.PDBIO.parse_pdb_seqres_line"><code class="name flex">
<span>def <span class="ident">parse_pdb_seqres_line</span></span>(<span>line:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a SEQRES (sequence) line from a PDB file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse_pdb_seqres_line(line: str):
    &#34;&#34;&#34;
    Parse a SEQRES (sequence) line from a PDB file.
    &#34;&#34;&#34;
    pdb_seqres_dict = {
        &#34;record_name&#34;: &#34;SEQRES&#34;,
        &#34;chain_id&#34;: line[11],
        &#34;residues&#34;: line[19:].strip().split()
    }

    return pdb_seqres_dict</code></pre>
</details>
</dd>
<dt id="protkit.file_io.pdb_io.PDBIO.parse_pdb_ter_line"><code class="name flex">
<span>def <span class="ident">parse_pdb_ter_line</span></span>(<span>line:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a TER (chain termination) line from a PDB file.</p>
<h2 id="columns-data-type-field-definition">Columns
Data
Type
Field
Definition</h2>
<p>1 -
6
Record name
"TER
"
7 - 11
Integer
serial
Serial number.
18 - 20
Residue name
resName
Residue name.
22
Character
chainID
Chain identifier.
23 - 26
Integer
resSeq
Residue sequence number.
27
AChar
iCode
Insertion code.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse_pdb_ter_line(line: str):
    &#34;&#34;&#34;
    Parse a TER (chain termination) line from a PDB file.

    COLUMNS        DATA  TYPE    FIELD           DEFINITION
    -------------------------------------------------------------------------
     1 -  6        Record name   &#34;TER   &#34;
     7 - 11        Integer       serial          Serial number.
    18 - 20        Residue name  resName         Residue name.
    22             Character     chainID         Chain identifier.
    23 - 26        Integer       resSeq          Residue sequence number.
    27             AChar         iCode           Insertion code.

    &#34;&#34;&#34;
    if line == &#34;TER&#34;:
        pdb_ter_dict = {
            &#34;record_name&#34;: &#34;TER&#34;,
            &#34;serial&#34;: &#34;&#34;,
            &#34;res_name&#34;: &#34;&#34;,
            &#34;chain_id&#34;: &#34;&#34;,
            &#34;res_seq&#34;: &#34;&#34;,
            &#34;icode&#34;: &#34;&#34;
        }
    else:
        line = line.ljust(80)
        pdb_ter_dict = {
            &#34;record_name&#34;: &#34;TER&#34;,
            &#34;serial&#34;: line[6:11],
            &#34;res_name&#34;: line[17:21],
            &#34;chain_id&#34;: line[21],
            &#34;res_seq&#34;: line[22:26],
            &#34;icode&#34;: line[26]
        }
    return pdb_ter_dict</code></pre>
</details>
</dd>
<dt id="protkit.file_io.pdb_io.PDBIO.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>protein:Â <a title="protkit.structure.protein.Protein" href="../structure/protein.html#protkit.structure.protein.Protein">Protein</a>, file_path:Â str, is_pqr_format=False) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def save(protein: Protein,
         file_path: str,
         is_pqr_format=False) -&gt; None:

    pdb_string = PDBIO.save_to_string(protein, is_pqr_format=is_pqr_format)

    with open(file_path, &#34;w&#34;) as file:
        file.write(pdb_string)</code></pre>
</details>
</dd>
<dt id="protkit.file_io.pdb_io.PDBIO.save_to_string"><code class="name flex">
<span>def <span class="ident">save_to_string</span></span>(<span>protein:Â <a title="protkit.structure.protein.Protein" href="../structure/protein.html#protkit.structure.protein.Protein">Protein</a>, is_pqr_format=False) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def save_to_string(protein: Protein,
                   is_pqr_format=False) -&gt; str:
    text_entries = []
    num_seqres = 0
    num_atoms = 0
    num_hetatoms = 0
    num_ter = 0
    serial = 1
    atom_entry = None

    for chain in protein.chains:
        for residue in chain.residues:
            for atom in residue.atoms:
                if not atom.is_hetero:
                    atom_entry = {
                        &#34;element&#34;: atom.element,
                        &#34;atom_name&#34;: atom.atom_type,
                        &#34;alt_loc&#34;: atom.get_attribute(&#34;pdb_alt_loc&#34;),
                        &#34;res_name&#34;: residue.residue_type,
                        &#34;chain_id&#34;: chain.chain_id,
                        &#34;res_seq&#34;: str(residue.sequence_no),
                        &#34;icode&#34;: residue.insertion_code,
                        &#34;x&#34;: atom.x,
                        &#34;y&#34;: atom.y,
                        &#34;z&#34;: atom.z,
                        &#34;occupancy&#34;: atom.get_attribute(&#34;occupancy&#34;),
                        # &#34;temp_factor&#34;: atom._pdb_temp_factor if atom._pdb_temp_factor is not None else 0.0,
                        &#34;temp_factor&#34;: atom.get_attribute(&#34;temp_factor&#34;),
                        &#34;assigned_charge&#34;: atom.get_attribute(&#34;assigned_charge&#34;),
                        &#34;calculated_charge&#34;: atom.get_attribute(&#34;calculated_charge&#34;),
                        &#34;radius&#34;: atom.get_attribute(&#34;radius&#34;)
                    }
                    if not is_pqr_format:
                        text_entries.append(PDBIO.create_pdb_atom_line(atom_entry, serial))
                    else:
                        text_entries.append(PDBIO.create_pqr_atom_line(atom_entry, serial))

                    serial += 1
                    num_atoms += 1

        # TER entry
        if atom_entry is not None:
            text_entries.append(PDBIO.create_pdb_ter_line(serial,
                                                          atom_entry[&#34;res_name&#34;],
                                                          atom_entry[&#34;chain_id&#34;],
                                                          atom_entry[&#34;res_seq&#34;],
                                                          atom_entry[&#34;icode&#34;]))
            serial = serial + 1
            num_ter += 1

    for chain in protein.chains:
        for residue in chain.residues:
            # HETATM entries
            for atom in residue.atoms:
                if atom.is_hetero:
                    atom_entry = {
                        &#34;element&#34;: atom.element,
                        &#34;atom_name&#34;: atom.atom_type,
                        &#34;alt_loc&#34;: atom.get_attribute(&#34;pdb_alt_loc&#34;),
                        &#34;res_name&#34;: residue.residue_type,
                        &#34;chain_id&#34;: chain.chain_id,
                        &#34;res_seq&#34;: str(residue.sequence_no),
                        &#34;icode&#34;: residue.insertion_code,
                        &#34;x&#34;: atom.x,
                        &#34;y&#34;: atom.y,
                        &#34;z&#34;: atom.z,
                        &#34;occupancy&#34;: atom.get_attribute(&#34;occupancy&#34;),
                        # &#34;temp_factor&#34;: atom._pdb_temp_factor if atom._pdb_temp_factor is not None else 0.0,
                        &#34;temp_factor&#34;: atom.get_attribute(&#34;temp_factor&#34;),
                        &#34;charge&#34;: atom.get_attribute(&#34;assigned_charge&#34;)
                    }
                    if not is_pqr_format:
                        text_entries.append(PDBIO.create_pdb_atom_line(atom_entry, serial, record_name=&#34;HETATM&#34;))
                    else:
                        text_entries.append(PDBIO.create_pqr_atom_line(atom_entry, serial, record_name=&#34;HETATM&#34;))

                    serial += 1
                    num_hetatoms += 1
        # Hetero residues have no TER records, so no need to write a termination code.

    # Bookkeeping records
    text_entries.append(PDBIO.create_pdb_master_line(num_atoms, num_hetatoms, num_ter, num_seqres=num_seqres))
    text_entries.append(&#34;END&#34;.ljust(80))

    return &#34;\n&#34;.join(text_entries)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="protkit.file_io" href="index.html">protkit.file_io</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="protkit.file_io.pdb_io.PDBIO" href="#protkit.file_io.pdb_io.PDBIO">PDBIO</a></code></h4>
<ul class="">
<li><code><a title="protkit.file_io.pdb_io.PDBIO.create_pdb_atom_line" href="#protkit.file_io.pdb_io.PDBIO.create_pdb_atom_line">create_pdb_atom_line</a></code></li>
<li><code><a title="protkit.file_io.pdb_io.PDBIO.create_pdb_end_model_line" href="#protkit.file_io.pdb_io.PDBIO.create_pdb_end_model_line">create_pdb_end_model_line</a></code></li>
<li><code><a title="protkit.file_io.pdb_io.PDBIO.create_pdb_master_line" href="#protkit.file_io.pdb_io.PDBIO.create_pdb_master_line">create_pdb_master_line</a></code></li>
<li><code><a title="protkit.file_io.pdb_io.PDBIO.create_pdb_model_line" href="#protkit.file_io.pdb_io.PDBIO.create_pdb_model_line">create_pdb_model_line</a></code></li>
<li><code><a title="protkit.file_io.pdb_io.PDBIO.create_pdb_ter_line" href="#protkit.file_io.pdb_io.PDBIO.create_pdb_ter_line">create_pdb_ter_line</a></code></li>
<li><code><a title="protkit.file_io.pdb_io.PDBIO.create_pqr_atom_line" href="#protkit.file_io.pdb_io.PDBIO.create_pqr_atom_line">create_pqr_atom_line</a></code></li>
<li><code><a title="protkit.file_io.pdb_io.PDBIO.create_seqres_line" href="#protkit.file_io.pdb_io.PDBIO.create_seqres_line">create_seqres_line</a></code></li>
<li><code><a title="protkit.file_io.pdb_io.PDBIO.load" href="#protkit.file_io.pdb_io.PDBIO.load">load</a></code></li>
<li><code><a title="protkit.file_io.pdb_io.PDBIO.load_from_string" href="#protkit.file_io.pdb_io.PDBIO.load_from_string">load_from_string</a></code></li>
<li><code><a title="protkit.file_io.pdb_io.PDBIO.parse_pdb_atom_line" href="#protkit.file_io.pdb_io.PDBIO.parse_pdb_atom_line">parse_pdb_atom_line</a></code></li>
<li><code><a title="protkit.file_io.pdb_io.PDBIO.parse_pdb_end_model_line" href="#protkit.file_io.pdb_io.PDBIO.parse_pdb_end_model_line">parse_pdb_end_model_line</a></code></li>
<li><code><a title="protkit.file_io.pdb_io.PDBIO.parse_pdb_entries" href="#protkit.file_io.pdb_io.PDBIO.parse_pdb_entries">parse_pdb_entries</a></code></li>
<li><code><a title="protkit.file_io.pdb_io.PDBIO.parse_pdb_entries_from_string" href="#protkit.file_io.pdb_io.PDBIO.parse_pdb_entries_from_string">parse_pdb_entries_from_string</a></code></li>
<li><code><a title="protkit.file_io.pdb_io.PDBIO.parse_pdb_model_line" href="#protkit.file_io.pdb_io.PDBIO.parse_pdb_model_line">parse_pdb_model_line</a></code></li>
<li><code><a title="protkit.file_io.pdb_io.PDBIO.parse_pdb_seqres_line" href="#protkit.file_io.pdb_io.PDBIO.parse_pdb_seqres_line">parse_pdb_seqres_line</a></code></li>
<li><code><a title="protkit.file_io.pdb_io.PDBIO.parse_pdb_ter_line" href="#protkit.file_io.pdb_io.PDBIO.parse_pdb_ter_line">parse_pdb_ter_line</a></code></li>
<li><code><a title="protkit.file_io.pdb_io.PDBIO.save" href="#protkit.file_io.pdb_io.PDBIO.save">save</a></code></li>
<li><code><a title="protkit.file_io.pdb_io.PDBIO.save_to_string" href="#protkit.file_io.pdb_io.PDBIO.save_to_string">save_to_string</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>