<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>protkit.file_io.pdb_io API documentation</title>
<meta name="description" content="Implements class `PDBIO` to read and write data
from and to PDB files.
PDB files contain protein structural
information â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>protkit.file_io.pdb_io</code></h1>
</header>
<section id="section-intro">
<p>Implements class <code><a title="protkit.file_io.pdb_io.PDBIO" href="#protkit.file_io.pdb_io.PDBIO">PDBIO</a></code> to read and write data
from and to PDB files.
PDB files contain protein structural
information.</p>
<p>The PDB File Format Specification is available at:
<a href="https://www.wwpdb.org/documentation/file-format-content/format33/v3.3.html">https://www.wwpdb.org/documentation/file-format-content/format33/v3.3.html</a></p>
<p>Currently, PDB records related to structural and sequence data is parsed
and saved.
Other fields are ignored. The following fields are processed:</p>
<ul>
<li>MODEL (model start)</li>
<li>ENDMDL (model end)</li>
<li>ATOM (structural data)</li>
<li>HETATOM (structural data)</li>
<li>SEQRES (sequence data)</li>
<li>TER (chain termination)</li>
<li>MASTER (record keeping)</li>
</ul>
<p>Methods are static and can be called without instantiating the class.
The main functions exposed by the class are:</p>
<ul>
<li><code>load()</code> to load a protein from a PDB file.</li>
<li><code>save()</code> to save a protein to a PDB file.</li>
</ul>
<p><font color="red">Saving a file in PQR format is not supported yet.</font></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding:utf-8 -*-
# Authors:  Fred Senekal (FS)
# Contact:  fred@silicogenesis.com
# License:  GPLv3

&#34;&#34;&#34;
Implements class `PDBIO` to read and write data
from and to PDB files.  PDB files contain protein structural
information.

The PDB File Format Specification is available at:
https://www.wwpdb.org/documentation/file-format-content/format33/v3.3.html

Currently, PDB records related to structural and sequence data is parsed
and saved.  Other fields are ignored. The following fields are processed:

- MODEL (model start)
- ENDMDL (model end)
- ATOM (structural data)
- HETATOM (structural data)
- SEQRES (sequence data)
- TER (chain termination)
- MASTER (record keeping)

Methods are static and can be called without instantiating the class.
The main functions exposed by the class are:

- `load()` to load a protein from a PDB file.
- `save()` to save a protein to a PDB file.

&lt;font color=&#34;red&#34;&gt;Saving a file in PQR format is not supported yet.&lt;/font&gt;

&#34;&#34;&#34;

from typing import List, Optional
from protkit.structure.protein import Protein
from protkit.structure.chain import Chain
from protkit.structure.residue import Residue
from protkit.structure.atom import Atom


class PDBIO():
    # --------------------------------------------------------------------------------
    # MODEL
    # --------------------------------------------------------------------------------

    @staticmethod
    def parse_pdb_model_line(line: str):
        &#34;&#34;&#34;
        Parse a MODEL (start model) line from a PDB file.

        COLUMNS        DATA  TYPE    FIELD          DEFINITION
        ---------------------------------------------------------------------------------------
         1 -  6        Record name   &#34;MODEL &#34;
        11 - 14        Integer       serial         Model serial number.
        &#34;&#34;&#34;
        pdb_model_dict = {
            &#34;record_name&#34;: &#34;MODEL&#34;,
            &#34;serial&#34;: line[10:14]
        }

        return pdb_model_dict

    @staticmethod
    def create_pdb_model_line(serial: int):
        &#34;&#34;&#34;
        Creates a MODEL (start model) line for a PDB file.
        &#34;&#34;&#34;
        return &#34;MODEL&#34;.ljust(10) + str(serial).rjust(4) + &#34;&#34;.ljust(66)

    # --------------------------------------------------------------------------------
    # ENDMDL
    # --------------------------------------------------------------------------------

    @staticmethod
    def parse_pdb_end_model_line(line: str):
        &#34;&#34;&#34;
        Parse a ENDMDL (end model) line from a PDB file.

        COLUMNS       DATA  TYPE     FIELD        DEFINITION
        ------------------------------------------------------------------
        1 - 6         Record name   &#34;ENDMDL&#34;

        &#34;&#34;&#34;
        pdb_end_model_dict = {
            &#34;record_name&#34;: &#34;ENDMDL&#34;
        }

        return pdb_end_model_dict

    @staticmethod
    def create_pdb_end_model_line():
        &#34;&#34;&#34;
        Creates a ENDMDL (end model) line for a PDB file.
        &#34;&#34;&#34;
        return &#34;ENDMDL&#34;.ljust(80)

    # --------------------------------------------------------------------------------
    # MASTER
    # --------------------------------------------------------------------------------

    @staticmethod
    def create_pdb_master_line(num_atoms, num_hetatoms, num_ter, num_remark=0, num_het=0, num_helix=0, num_sheet=0,
                               num_site=0, num_trans=0, num_conect=0, num_seqres=0):
        &#34;&#34;&#34;
        Creates a MASTER (recordkeeping) line for a PDB file.

        COLUMNS         DATA TYPE     FIELD          DEFINITION
        ----------------------------------------------------------------------------------
         1 -  6         Record name   &#34;MASTER&#34;
        11 - 15         Integer       numRemark      Number of REMARK records
        16 - 20         Integer       &#34;0&#34;
        21 - 25         Integer       numHet         Number of HET records
        26 - 30         Integer       numHelix       Number of HELIX records
        31 - 35         Integer       numSheet       Number of SHEET records
        36 - 40         Integer       numTurn        deprecated
        41 - 45         Integer       numSite        Number of SITE records
        46 - 50         Integer       numXform       Number of coordinate transformation
                                                     records  (ORIGX+SCALE+MTRIX)
        51 - 55         Integer       numCoord       Number of atomic coordinate records
                                                     records (ATOM+HETATM)
        56 - 60         Integer       numTer         Number of TER records
        61 - 65         Integer       numConect      Number of CONECT records
        66 - 70         Integer       numSeq         Number of SEQRES records
        &#34;&#34;&#34;

        entries = [
            &#34;MASTER&#34;.ljust(10),
            str(num_remark).rjust(5),
            &#34;0&#34;.rjust(5),
            str(num_het).rjust(5),
            str(num_helix).rjust(5),
            str(num_sheet).rjust(5),
            &#34;0&#34;.rjust(5),
            str(num_site).rjust(5),
            str(num_trans).rjust(5),
            str(num_atoms + num_hetatoms).rjust(5),
            str(num_ter).rjust(5),
            str(num_conect).rjust(5),
            str(num_seqres).rjust(5),
            &#34;&#34;.ljust(10)
        ]

        return &#34;&#34;.join(entries)

    # --------------------------------------------------------------------------------
    # SEQRES
    # --------------------------------------------------------------------------------

    @staticmethod
    def parse_pdb_seqres_line(line: str):
        &#34;&#34;&#34;
        Parse a SEQRES (sequence) line from a PDB file.
        &#34;&#34;&#34;
        pdb_seqres_dict = {
            &#34;record_name&#34;: &#34;SEQRES&#34;,
            &#34;chain_id&#34;: line[11],
            &#34;residues&#34;: line[19:].strip().split()
        }

        return pdb_seqres_dict

    @staticmethod
    def create_seqres_line(line_no, chain_id, num_residues, residues):
        &#34;&#34;&#34;
        Creates a SEQRES (sequence) line for a PDB file.

         1 -  6        Record name    &#34;SEQRES&#34;
         8 - 10        Integer        serNum       Serial number of the SEQRES record for  the
                                                   current  chain. Starts at 1 and increments
                                                   by one  each line. Reset to 1 for each chain.
        12             Character      chainID      Chain identifier. This may be any single
                                                   legal  character, including a blank which
                                                   is used if there is only one chain.
        14 - 17        Integer        numRes       Number of residues in the chain.
                                                   This  value is repeated on every record.
        20 - 22        Residue name   resName      Residue name.
        24 - 26        Residue name   resName      Residue name.
        28 - 30        Residue name   resName      Residue name.
        32 - 34        Residue name   resName      Residue name.
        36 - 38        Residue name   resName      Residue name.
        40 - 42        Residue name   resName      Residue name.
        44 - 46        Residue name   resName      Residue name.
        48 - 50        Residue name   resName      Residue name.
        52 - 54        Residue name   resName      Residue name.
        56 - 58        Residue name   resName      Residue name.
        60 - 62        Residue name   resName      Residue name.
        64 - 66        Residue name   resName      Residue name.
        68 - 70        Residue name   resName      Residue name.
        &#34;&#34;&#34;
        entries = [
            &#34;SEQRES &#34;,
            str(line_no).rjust(3) + &#34; &#34;,
            chain_id + &#34; &#34;,
            str(num_residues).rjust(4) + &#34;  &#34;
        ]
        for residue in residues:
            entries.append(residue[&#34;residue&#34;].rjust(3) + &#34; &#34;)
        return &#34;&#34;.join(entries).ljust(80)

    # --------------------------------------------------------------------------------
    # TER
    # --------------------------------------------------------------------------------

    @staticmethod
    def parse_pdb_ter_line(line: str):
        &#34;&#34;&#34;
        Parse a TER (chain termination) line from a PDB file.

        COLUMNS        DATA  TYPE    FIELD           DEFINITION
        -------------------------------------------------------------------------
         1 -  6        Record name   &#34;TER   &#34;
         7 - 11        Integer       serial          Serial number.
        18 - 20        Residue name  resName         Residue name.
        22             Character     chainID         Chain identifier.
        23 - 26        Integer       resSeq          Residue sequence number.
        27             AChar         iCode           Insertion code.

        &#34;&#34;&#34;
        if line == &#34;TER&#34;:
            pdb_ter_dict = {
                &#34;record_name&#34;: &#34;TER&#34;,
                &#34;serial&#34;: &#34;&#34;,
                &#34;res_name&#34;: &#34;&#34;,
                &#34;chain_id&#34;: &#34;&#34;,
                &#34;res_seq&#34;: &#34;&#34;,
                &#34;icode&#34;: &#34;&#34;
            }
        else:
            line = line.ljust(80)
            pdb_ter_dict = {
                &#34;record_name&#34;: &#34;TER&#34;,
                &#34;serial&#34;: line[6:11],
                &#34;res_name&#34;: line[17:21],
                &#34;chain_id&#34;: line[21],
                &#34;res_seq&#34;: line[22:26],
                &#34;icode&#34;: line[26]
            }
        return pdb_ter_dict

    @staticmethod
    def create_pdb_ter_line(serial, res_name, chain_id, res_seq, icode):
        &#34;&#34;&#34;
        Creates a TER (chain termination) line for a PDB file.
        &#34;&#34;&#34;
        text = &#34;TER&#34;.ljust(6)
        text += str(serial).rjust(5) + &#34;      &#34;
        text += res_name.rjust(3) + &#34; &#34;
        text += chain_id
        text += res_seq.rjust(4)
        text += icode.ljust(1)

        return text.ljust(80)

    # --------------------------------------------------------------------------------
    # ATOM | HETATM
    # --------------------------------------------------------------------------------

    @staticmethod
    def parse_pdb_atom_line(line, is_pqr_format: bool = False):
        &#34;&#34;&#34;
        Parse a ATOM (individual atom) or HETATM (hetero atom) line from a PDB file.

        COLUMNS        DATA  TYPE    FIELD        DEFINITION
        -------------------------------------------------------------------------------------
         1 -  6        Record name   &#34;ATOM  &#34;
         7 - 11        Integer       serial       Atom  serial number.
        13 - 16        Atom          name         Atom name.
        17             Character     altLoc       Alternate location indicator.
        18 - 20        Residue name  resName      Residue name.
        22             Character     chainID      Chain identifier.
        23 - 26        Integer       resSeq       Residue sequence number.
        27             AChar         iCode        Code for insertion of residues.
        31 - 38        Real(8.3)     x            Orthogonal coordinates for X in Angstroms.
        39 - 46        Real(8.3)     y            Orthogonal coordinates for Y in Angstroms.
        47 - 54        Real(8.3)     z            Orthogonal coordinates for Z in Angstroms.
        55 - 60        Real(6.2)     occupancy    Occupancy.
        61 - 66        Real(6.2)     tempFactor   Temperature  factor.
        77 - 78        LString(2)    element      Element symbol, right-justified.
        79 - 80        LString(2)    charge       Charge  on the atom.`
        &#34;&#34;&#34;
        if not is_pqr_format:
            pdb_atom_dict = {
                &#34;record_name&#34;: line[0:6].strip().upper(),
                &#34;serial&#34;: line[6:11].strip(),
                # Open space
                &#34;atom_name&#34;: line[12:16].strip(),
                &#34;alt_loc&#34;: line[16].strip(),
                &#34;res_name&#34;: line[17:20].strip(),
                # Open space
                &#34;chain_id&#34;: line[21].strip(),
                &#34;res_seq&#34;: line[22:26].strip(),
                &#34;icode&#34;: line[26].strip(),
                # 3x Open space
                &#34;x&#34;: float(line[30:38]),
                &#34;y&#34;: float(line[38:46]),
                &#34;z&#34;: float(line[46:54]),
                &#34;occupancy&#34;: float(line[54:60]),
                # &#34;temp_factor&#34;: None,
                &#34;temp_factor&#34;: float(line[60:66]),
                # 66 - 75?
                &#34;element&#34;: line[76:78].strip(),
                &#34;assigned_charge&#34;: line[78:80].strip(),
                &#34;calculated_charge&#34;: None,
                &#34;radius&#34;: None
            }
        else:
            pdb_atom_dict = {
                &#34;record_name&#34;: line[0:6].strip().upper(),
                &#34;serial&#34;: line[6:11].strip(),
                # Open space
                &#34;atom_name&#34;: line[12:16].strip(),
                &#34;alt_loc&#34;: line[16].strip(),
                &#34;res_name&#34;: line[17:20].strip(),
                # Open space
                &#34;chain_id&#34;: line[21].strip(),
                &#34;res_seq&#34;: line[22:26].strip(),
                &#34;icode&#34;: line[26].strip(),
                # 3x Open space
                &#34;x&#34;: float(line[30:38]),
                &#34;y&#34;: float(line[38:46]),
                &#34;z&#34;: float(line[46:54]),

                &#34;occupancy&#34;: 1.0,
                &#34;temp_factor&#34;: None,

                &#34;element&#34;: line[76:78].strip(),
                &#34;assigned_charge&#34;: None,
                &#34;calculated_charge&#34;: float(line[54:62]),
                &#34;radius&#34;: float(line[62:70])
            }
        return pdb_atom_dict

    @staticmethod
    def create_pdb_atom_line(atom, serial: int, record_name=&#34;ATOM&#34;):
        &#34;&#34;&#34;
        Creates a ATOM line for a PDB file.

        The record_name is expected to be ATOM or HETATM
        &#34;&#34;&#34;
        # text = &#34;ATOM&#34;.ljust(6)
        # text += atom[&#34;serial&#34;].rjust(5) + &#34; &#34;
        text = record_name.ljust(6)
        text += str(serial).rjust(5) + &#34; &#34;

        # The PDB spec says that if the element has two characters, e.g. Fe (iron)
        # it should start at the position 13, otherwise it should start at position 14.
        # This seems a little problematic, as some atoms could use 4 characters
        # for example, HG11. The implementation here is consistent with observed PDBs
        # from the RCSB.
        if len(atom[&#34;element&#34;]) == 2 or len(atom[&#34;atom_name&#34;]) == 4:
            text += atom[&#34;atom_name&#34;].ljust(4)
        else:
            text += &#34; &#34; + atom[&#34;atom_name&#34;].ljust(3)
        text += (&#34;&#34; if atom[&#34;alt_loc&#34;] is None else atom[&#34;alt_loc&#34;]).ljust(1)
        text += atom[&#34;res_name&#34;].rjust(3) + &#34; &#34;
        text += atom[&#34;chain_id&#34;]
        text += atom[&#34;res_seq&#34;].rjust(4)
        text += atom[&#34;icode&#34;].ljust(1) + &#34;   &#34;
        text += f&#39;{atom[&#34;x&#34;]:8.3f}&#39;
        text += f&#39;{atom[&#34;y&#34;]:8.3f}&#39;
        text += f&#39;{atom[&#34;z&#34;]:8.3f}&#39;
        text += f&#39;{1.0 if atom[&#34;occupancy&#34;] is None else atom[&#34;occupancy&#34;]:6.2f}&#39;
        text += f&#39;{0.0 if atom[&#34;temp_factor&#34;] is None else atom[&#34;temp_factor&#34;]:6.2f}&#39;
        text += &#34;&#34;.ljust(10)
        text += atom[&#34;element&#34;].rjust(2)
        text += (&#34;&#34; if atom[&#34;charge&#34;] is None else atom[&#34;charge&#34;]).rjust(2)
        return text

    # --------------------------------------------------------------------------------
    # Main parsing and saving functions
    # --------------------------------------------------------------------------------

    @staticmethod
    def parse_pdb_entries(file_path: str, is_pqr_format: bool = False):
        &#34;&#34;&#34;
        Parse PDB file according to the spec provided at:
        https://www.wwpdb.org/documentation/file-format-content/format33/sect9.html#ATOM
        &#34;&#34;&#34;
        # Open the file and extract the individual lines.
        with open(file_path) as file:
            lines = file.read().split(&#34;\n&#34;)

        # Parse every line into dictionary information
        entries = []
        for line in lines:
            record_name = line[0:6].strip().upper()
            if record_name == &#34;ATOM&#34;:
                pdb_atom_dict = PDBIO.parse_pdb_atom_line(line)
                entries.append(pdb_atom_dict)
            elif record_name == &#34;HETATM&#34;:
                pdb_atom_dict = PDBIO.parse_pdb_atom_line(line, is_pqr_format=is_pqr_format)
                entries.append(pdb_atom_dict)
            elif record_name == &#34;TER&#34;:
                pdb_ter_dict = PDBIO.parse_pdb_ter_line(line)
                entries.append(pdb_ter_dict)
            elif record_name == &#34;MODEL&#34;:
                pdb_model_dict = PDBIO.parse_pdb_model_line(line)
                entries.append(pdb_model_dict)
            elif record_name == &#34;ENDMDL&#34;:
                pdb_end_model_dict = PDBIO.parse_pdb_end_model_line(line)
                entries.append(pdb_end_model_dict)
            elif record_name == &#34;SEQRES&#34;:
                pdb_seqres_dict = PDBIO.parse_pdb_seqres_line(line)
                entries.append(pdb_seqres_dict)
        return entries

    @staticmethod
    def load(file_path: str,
             is_pqr_format: bool = False,
             pdb_id: Optional[str] = None) -&gt; List[Protein]:

        protein = Protein(pdb_id=pdb_id)
        models = []
        seqres = {}
        current_model = None
        current_chain: Optional[Chain] = None
        current_chain_id = None
        current_residue: Optional[Residue] = None
        current_residue_id = None
        entries = PDBIO.parse_pdb_entries(file_path, is_pqr_format=is_pqr_format)

        for entry in entries:
            record_name = entry[&#34;record_name&#34;]
            if record_name == &#34;SEQRES&#34;:
                chain_id = entry[&#34;chain_id&#34;]
                if chain_id not in seqres:
                    seqres[chain_id] = []
                seqres[chain_id].extend(entry[&#34;residues&#34;])
            elif record_name == &#34;MODEL&#34;:
                # Usually, the MODEL field will only be found in structures based on NMR.
                # We only use the first model in a file if provided.
                # There is nothing to do, so we
                pass
            elif record_name == &#34;ENDMDL&#34;:
                # Usually, the ENDMDL field will only be found in structures based on NMR.
                # it closes a corresponding MODEL field.
                # Since the end of the model is reached, no more entries should be parsed.
                break
            elif record_name == &#34;TER&#34;:
                # The TER field terminates the current chain.
                current_chain = None
                current_chain_id = None
            elif record_name == &#34;ATOM&#34; or record_name == &#34;HETATM&#34;:
                # If we switched chains, set the chain.
                if entry[&#34;chain_id&#34;] != current_chain_id:
                    current_chain_id = entry[&#34;chain_id&#34;]
                    if protein.has_chain(current_chain_id):
                        current_chain = protein.get_chain(current_chain_id)
                    else:
                        current_chain = protein.create_chain(current_chain_id)

                # Check if the residue exists
                residue_id = current_chain_id + entry[&#34;res_seq&#34;] + entry[&#34;icode&#34;]
                if residue_id != current_residue_id:
                    current_residue_id = residue_id
                    if record_name == &#34;ATOM&#34;:
                        # if entry[&#34;res_name&#34;] in ResidueTemplate.VALID_DNA_RESIDUES:
                        #     current_residue = current_chain.add_dna_residue(
                        #         residue_type=entry[&#34;res_name&#34;],
                        #         sequence_no=int(entry[&#34;res_seq&#34;]),
                        #         insertion_code=entry[&#34;icode&#34;]
                        #     )
                        # else:
                        current_residue = Residue(
                            residue_type=entry[&#34;res_name&#34;],
                            sequence_no=int(entry[&#34;res_seq&#34;]),
                            insertion_code=entry[&#34;icode&#34;],
                            chain=current_chain)
                        current_chain.add_residue(current_residue)
                    elif record_name == &#34;HETATM&#34;:
                        current_residue = Residue(
                            residue_type=entry[&#34;res_name&#34;],
                            sequence_no=int(entry[&#34;res_seq&#34;]),
                            insertion_code=entry[&#34;icode&#34;],
                            chain=current_chain)
                        current_chain.add_residue(current_residue)

                        # current_residue = current_chain.add_het_residue(
                        #     residue_type=entry[&#34;res_name&#34;],
                        #     sequence_no=int(entry[&#34;res_seq&#34;]),
                        #     insertion_code=entry[&#34;icode&#34;]
                        # )

                # Temporary fix need to see if anything breaks (For Evo eg. 2HH1 -&gt; HH12)
                # Fix atom naming
                if entry[&#34;atom_name&#34;][0].isnumeric():
                    entry[&#34;atom_name&#34;] = entry[&#34;atom_name&#34;][1:] + entry[&#34;atom_name&#34;][0]
                    if entry[&#34;element&#34;] != &#34;H&#34;:
                        print(0)
                    if entry[&#34;atom_name&#34;][0] == &#34;H&#34;:
                        entry[&#34;element&#34;] = &#34;H&#34;

                # Add the atom to the residue
                # if entry[&#34;alt_loc&#34;] == &#34;&#34;:
                #     atom_id = entry[&#34;atom_name&#34;]
                # else:
                #     atom_id = entry[&#34;atom_name&#34;] + &#34;_&#34; + entry[&#34;alt_loc&#34;]
                atom = Atom(
                    element=entry[&#34;element&#34;],
                    atom_type=entry[&#34;atom_name&#34;],
                    x=entry[&#34;x&#34;],
                    y=entry[&#34;y&#34;],
                    z=entry[&#34;z&#34;],

                    # Serial is dependent on the atom ordering,
                    # so it is not used in the Atom class
                    # pdb_serial=entry[&#34;serial&#34;],
                    alt_loc=entry[&#34;alt_loc&#34;],
                    occupancy=entry[&#34;occupancy&#34;],
                    temp_factor=entry[&#34;temp_factor&#34;],
                    assigned_charge=entry[&#34;assigned_charge&#34;],
                    # pqr_calculated_charge=entry[&#34;calculated_charge&#34;],
                    # pqr_radius=entry[&#34;radius&#34;],
                    #
                    is_hetero=(record_name == &#34;HETATM&#34;),

                    residue=current_residue
                )

                # current_residue.add_atom(atom_id, atom)
                current_residue.add_atom(atom.atom_type, atom)

        if seqres:
            for chain_id in seqres:
                if seqres[chain_id]:
                    protein.get_chain(chain_id).set_attribute(&#34;seqres&#34;, seqres[chain_id])

        # Housekeeping
        # protein.set_residue_indexing()

        return [protein]

    @staticmethod
    def save(protein: Protein,
             file_path: str,
             is_pqr_format=False) -&gt; None:
        text_entries = []
        num_seqres = 0
        num_atoms = 0
        num_hetatoms = 0
        num_ter = 0
        serial = 1

        for chain in protein.chains:
            for residue in chain.residues:
                for atom in residue.atoms:
                    if not atom.is_hetero:
                        atom_entry = {
                            &#34;element&#34;: atom.element,
                            &#34;atom_name&#34;: atom.atom_type,
                            &#34;alt_loc&#34;: atom.get_attribute(&#34;pdb_alt_loc&#34;),
                            &#34;res_name&#34;: residue.residue_type,
                            &#34;chain_id&#34;: chain.chain_id,
                            &#34;res_seq&#34;: str(residue.sequence_no),
                            &#34;icode&#34;: residue.insertion_code,
                            &#34;x&#34;: atom.x,
                            &#34;y&#34;: atom.y,
                            &#34;z&#34;: atom.z,
                            &#34;occupancy&#34;: atom.get_attribute(&#34;occupancy&#34;),
                            # &#34;temp_factor&#34;: atom._pdb_temp_factor if atom._pdb_temp_factor is not None else 0.0,
                            &#34;temp_factor&#34;: atom.get_attribute(&#34;temp_factor&#34;),
                            &#34;charge&#34;: atom.get_attribute(&#34;assigned_charge&#34;)
                        }
                        text_entries.append(PDBIO.create_pdb_atom_line(atom_entry, serial))
                        serial += 1
                        num_atoms += 1

        # Bookkeeping records
        text_entries.append(PDBIO.create_pdb_master_line(num_atoms, num_hetatoms, num_ter, num_seqres=num_seqres))
        text_entries.append(&#34;END&#34;.ljust(80))

        with open(file_path, &#34;w&#34;) as file:
            file.write(&#34;\n&#34;.join(text_entries))

    # TODO: from_pdb_text and to_pdb_text was added by Claudio
    # The intent is that one should parse proteins from text
    # without working with files. However, a lot of code copying
    # was made and it need to be reworked significantly.

    @staticmethod
    def from_pdb_text(lines) -&gt; List[Protein]:
        lines = lines.split(&#34;\n&#34;)

        entries = []
        for line in lines:
            record_name = line[0:6].strip().upper()
            if record_name == &#34;ATOM&#34;:
                pdb_atom_dict = PDBIO.parse_pdb_atom_line(line)
                entries.append(pdb_atom_dict)
            elif record_name == &#34;HETATM&#34;:
                pdb_atom_dict = PDBIO.parse_pdb_atom_line(line)
                entries.append(pdb_atom_dict)
            elif record_name == &#34;TER&#34;:
                pdb_ter_dict = PDBIO.parse_pdb_ter_line(line)
                entries.append(pdb_ter_dict)
            elif record_name == &#34;MODEL&#34;:
                pdb_model_dict = PDBIO.parse_pdb_model_line(line)
                entries.append(pdb_model_dict)
            elif record_name == &#34;ENDMDL&#34;:
                pdb_end_model_dict = PDBIO.parse_pdb_end_model_line(line)
                entries.append(pdb_end_model_dict)
            elif record_name == &#34;SEQRES&#34;:
                pdb_seqres_dict = PDBIO.parse_pdb_seqres_line(line)
                entries.append(pdb_seqres_dict)

        protein = Protein()
        models = []
        seqres = {}
        current_model = None
        current_chain: Optional[Chain] = None
        current_chain_id = None
        current_residue: Optional[Residue] = None
        current_residue_id = None

        for entry in entries:
            record_name = entry[&#34;record_name&#34;]
            if record_name == &#34;SEQRES&#34;:
                chain_id = entry[&#34;chain_id&#34;]
                if chain_id not in seqres:
                    seqres[chain_id] = []
                seqres[chain_id].extend(entry[&#34;residues&#34;])
            elif record_name == &#34;MODEL&#34;:
                # Usually, the MODEL field will only be found in structures based on NMR.
                # We only use the first model in a file if provided.
                # There is nothing to do, so we
                pass
            elif record_name == &#34;ENDMDL&#34;:
                # Usually, the ENDMDL field will only be found in structures based on NMR.
                # it closes a corresponding MODEL field.
                # Since the end of the model is reached, no more entries should be parsed.
                break
            elif record_name == &#34;TER&#34;:
                # The TER field terminates the current chain.
                current_chain = None
                current_chain_id = None
            elif record_name == &#34;ATOM&#34; or record_name == &#34;HETATM&#34;:
                # If we switched chains, set the chain.
                if entry[&#34;chain_id&#34;] != current_chain_id:
                    current_chain_id = entry[&#34;chain_id&#34;]
                    if protein.has_chain(current_chain_id):
                        current_chain = protein.get_chain(current_chain_id)
                    else:
                        current_chain = protein.create_chain(current_chain_id)

                # Check if the residue exists
                residue_id = current_chain_id + entry[&#34;res_seq&#34;] + entry[&#34;icode&#34;]
                if residue_id != current_residue_id:
                    current_residue_id = residue_id
                    if record_name == &#34;ATOM&#34;:
                        # if entry[&#34;res_name&#34;] in ResidueTemplate.VALID_DNA_RESIDUES:
                        #     current_residue = current_chain.add_dna_residue(
                        #         residue_type=entry[&#34;res_name&#34;],
                        #         sequence_no=int(entry[&#34;res_seq&#34;]),
                        #         insertion_code=entry[&#34;icode&#34;]
                        #     )
                        # else:
                        current_residue = Residue(
                            residue_type=entry[&#34;res_name&#34;],
                            sequence_no=int(entry[&#34;res_seq&#34;]),
                            insertion_code=entry[&#34;icode&#34;],
                            chain=current_chain)
                        current_chain.add_residue(current_residue)
                    elif record_name == &#34;HETATM&#34;:
                        current_residue = Residue(
                            residue_type=entry[&#34;res_name&#34;],
                            sequence_no=int(entry[&#34;res_seq&#34;]),
                            insertion_code=entry[&#34;icode&#34;],
                            chain=current_chain)
                        current_chain.add_residue(current_residue)

                        # current_residue = current_chain.add_het_residue(
                        #     residue_type=entry[&#34;res_name&#34;],
                        #     sequence_no=int(entry[&#34;res_seq&#34;]),
                        #     insertion_code=entry[&#34;icode&#34;]
                        # )

                # Temporary fix need to see if anything breaks (For Evo eg. 2HH1 -&gt; HH12)
                # Fix atom naming
                if entry[&#34;atom_name&#34;][0].isnumeric():
                    entry[&#34;atom_name&#34;] = entry[&#34;atom_name&#34;][1:] + entry[&#34;atom_name&#34;][0]
                    if entry[&#34;element&#34;] != &#34;H&#34;:
                        print(0)
                    if entry[&#34;atom_name&#34;][0] == &#34;H&#34;:
                        entry[&#34;element&#34;] = &#34;H&#34;

                # Add the atom to the residue
                if entry[&#34;alt_loc&#34;] == &#34;&#34;:
                    atom_id = entry[&#34;atom_name&#34;]
                else:
                    atom_id = entry[&#34;atom_name&#34;] + &#34;_&#34; + entry[&#34;alt_loc&#34;]
                atom = Atom(
                    element=entry[&#34;element&#34;],
                    atom_type=entry[&#34;atom_name&#34;],
                    x=entry[&#34;x&#34;],
                    y=entry[&#34;y&#34;],
                    z=entry[&#34;z&#34;],

                    # pdb_serial=entry[&#34;serial&#34;],
                    # pdb_alt_loc=entry[&#34;alt_loc&#34;],
                    # pdb_occupancy=entry[&#34;occupancy&#34;],
                    # pdb_temp_factor=entry[&#34;temp_factor&#34;],
                    # pdb_assigned_charge=entry[&#34;assigned_charge&#34;],
                    # pqr_calculated_charge=entry[&#34;calculated_charge&#34;],
                    # pqr_radius=entry[&#34;radius&#34;],
                    #
                    is_hetero=(record_name == &#34;HETATM&#34;),

                    residue=current_residue
                )
                current_residue.add_atom(atom_id, atom)

        # if seqres:
        #     for chain_id in seqres:
        #         if seqres[chain_id]:
        #             protein.chains[chain_id].sequence = seqres[chain_id]

        # Housekeeping
        # protein.set_residue_indexing()

        return [protein]

    @staticmethod
    def to_pdb_text(protein: Protein):
        text_entries = &#34;&#34;
        num_seqres = 0
        num_atoms = 0
        num_hetatoms = 0
        num_ter = 0
        serial = 1

        for chain in protein.chains:
            for residue in chain.residues:
                for atom in residue.atoms:
                    if not atom.is_hetero:
                        atom_entry = {
                            &#34;element&#34;: atom.element,
                            &#34;atom_name&#34;: atom.atom_type,
                            &#34;alt_loc&#34;: atom.get_attribute(&#34;pdb_alt_loc&#34;),
                            &#34;res_name&#34;: residue.residue_type,
                            &#34;chain_id&#34;: chain.chain_id,
                            &#34;res_seq&#34;: str(residue.sequence_no),
                            &#34;icode&#34;: residue.insertion_code,
                            &#34;x&#34;: atom.x,
                            &#34;y&#34;: atom.y,
                            &#34;z&#34;: atom.z,
                            &#34;occupancy&#34;: atom.get_attribute(&#34;occupancy&#34;),
                            # &#34;temp_factor&#34;: atom._pdb_temp_factor if atom._pdb_temp_factor is not None else 0.0,
                            &#34;temp_factor&#34;: atom.get_attribute(&#34;temp_factor&#34;),
                            &#34;charge&#34;: atom.get_attribute(&#34;assigned_charge&#34;)
                        }
                        text_entries += PDBIO.create_pdb_atom_line(atom_entry, serial)
                        text_entries += &#34;\n&#34;
                        serial += 1
                        num_atoms += 1

        # Bookkeeping records
        text_entries += PDBIO.create_pdb_master_line(num_atoms, num_hetatoms, num_ter, num_seqres=num_seqres)
        text_entries += &#34;END&#34;.ljust(80)
        text_entries += &#34;\n&#34;

        return text_entries


    # @staticmethod
    # def save_to_pdb(file_path: str, protein):
    #     entries = []
    #
    #     num_seqres = 0
    #     num_atoms = 0
    #     num_hetatoms = 0
    #     num_ter = 0
    #     serial = 1
    #
    #     for chain in protein.chains:
    #         for residue in chain.residues:
    #             # ATOM entries
    #             for atom in residue.atoms:
    #                 if not atom.is_hetero:
    #                     atom_entry = {
    #                         &#34;element&#34;: atom.element,
    #                         &#34;atom_name&#34;: atom.atom_type,
    #                         &#34;alt_loc&#34;: atom._pdb_alt_loc,
    #                         &#34;res_name&#34;: residue.residue_type,
    #                         &#34;chain_id&#34;: chain.chain_id,
    #                         &#34;res_seq&#34;: str(residue._pdb_sequence_no),
    #                         &#34;icode&#34;: residue._pdb_insertion_code,
    #                         &#34;x&#34;: atom.x,
    #                         &#34;y&#34;: atom.y,
    #                         &#34;z&#34;: atom.z,
    #                         &#34;occupancy&#34;: atom._pdb_occupancy,
    #                         &#34;temp_factor&#34;: atom._pdb_temp_factor if atom._pdb_temp_factor is not None else 0.0,
    #                         &#34;charge&#34;: atom._pdb_assigned_charge
    #                     }
    #                     entries.append(PDBParser.create_pdb_atom_line(atom_entry, serial))
    #                     serial += 1
    #                     num_atoms += 1
    #
    #         # TER entry
    #         if chain.num_residues - chain.num_hetero_residues &gt; 0:
    #             entries.append(
    #                 PDBParser.create_pdb_ter_line(serial, atom_entry[&#34;res_name&#34;], chain.chain_id, atom_entry[&#34;res_seq&#34;],
    #                                               atom_entry[&#34;icode&#34;]))
    #             serial = serial + 1
    #             num_ter += 1
    #
    #     for chain in protein.chains:
    #         for residue in chain.residues:
    #             # HETATM entries
    #             for atom in residue.atoms:
    #                 if atom.is_hetero:
    #                     atom_entry = {
    #                         &#34;element&#34;: atom.element,
    #                         &#34;atom_name&#34;: atom.atom_type,
    #                         &#34;alt_loc&#34;: atom._pdb_alt_loc,
    #                         &#34;res_name&#34;: residue.residue_type,
    #                         &#34;chain_id&#34;: chain.chain_id,
    #                         &#34;res_seq&#34;: str(residue._pdb_sequence_no),
    #                         &#34;icode&#34;: residue._pdb_insertion_code,
    #                         &#34;x&#34;: atom.x,
    #                         &#34;y&#34;: atom.y,
    #                         &#34;z&#34;: atom.z,
    #                         &#34;occupancy&#34;: atom._pdb_occupancy,
    #                         &#34;temp_factor&#34;: atom._pdb_temp_factor if atom._pdb_temp_factor is not None else 0.0,
    #                         &#34;charge&#34;: atom._pdb_assigned_charge
    #                     }
    #                     entries.append(PDBParser.create_pdb_atom_line(atom_entry, serial, &#34;HETATM&#34;))
    #                     serial += 1
    #                     num_hetatoms += 1
    #
    #         # Hetero residues have no TER records, so no need to write a termination code.
    #
    #     # Bookkeeping records
    #     entries.append(PDBParser.create_pdb_master_line(num_atoms, num_hetatoms, num_ter, num_seqres=num_seqres))
    #     entries.append(&#34;END&#34;.ljust(80))
    #
    #     # Write file
    #     with open(file_path, &#34;w&#34;) as file:
    #         file.write(&#34;\n&#34;.join(entries))

    # @staticmethod
    # def load_from_pdb(file_path: str):
    #     entries = PDBParser.parse_pdb_entries(file_path)
    #
    #     protein = Protein()
    #     models = []
    #     seqres = {}
    #     current_model = None
    #     current_chain: Chain = None
    #     current_chain_id = None
    #     current_residue: Residue = None
    #     current_residue_id = None
    #
    #     for entry in entries:
    #         record_name = entry[&#34;record_name&#34;]
    #         if record_name == &#34;SEQRES&#34;:
    #             chain_id = entry[&#34;chain_id&#34;]
    #             if chain_id not in seqres:
    #                 seqres[chain_id] = []
    #             seqres[chain_id].extend(entry[&#34;residues&#34;])
    #         elif record_name == &#34;MODEL&#34;:
    #             # Usually, the MODEL field will only be found in structures based on NMR.
    #             # We only use the first model in a file if provided.
    #             # There is nothing to do, so we
    #             pass
    #         elif record_name == &#34;ENDMDL&#34;:
    #             # Usually, the ENDMDL field will only be found in structures based on NMR.
    #             # it closes a corresponding MODEL field.
    #             # Since the end of the model is reached, no more entries should be parsed.
    #             break
    #         elif record_name == &#34;TER&#34;:
    #             # The TER field terminates the current chain.
    #             current_chain = None
    #             current_chain_id = None
    #         elif record_name == &#34;ATOM&#34; or record_name == &#34;HETATM&#34;:
    #             # If we switched chains, set the chain.
    #             if entry[&#34;chain_id&#34;] != current_chain_id:
    #                 current_chain_id = entry[&#34;chain_id&#34;]
    #                 if current_chain_id in protein._chains:
    #                     current_chain = protein._chains[current_chain_id]
    #                 else:
    #                     current_chain = protein.create_chain(current_chain_id)
    #
    #             # Check if the residue exists
    #             residue_id = current_chain_id + entry[&#34;res_seq&#34;] + entry[&#34;icode&#34;]
    #             if residue_id != current_residue_id:
    #                 current_residue_id = residue_id
    #                 if record_name == &#34;ATOM&#34;:
    #                     # if entry[&#34;res_name&#34;] in ResidueTemplate.VALID_DNA_RESIDUES:
    #                     #     current_residue = current_chain.add_dna_residue(
    #                     #         residue_type=entry[&#34;res_name&#34;],
    #                     #         sequence_no=int(entry[&#34;res_seq&#34;]),
    #                     #         insertion_code=entry[&#34;icode&#34;]
    #                     #     )
    #                     # else:
    #                     current_residue = Residue(
    #                         residue_type=entry[&#34;res_name&#34;],
    #                         pdb_sequence_no=int(entry[&#34;res_seq&#34;]),
    #                         pdb_insertion_code=entry[&#34;icode&#34;],
    #                         chain=current_chain)
    #                     current_chain.add_residue(current_residue)
    #                 elif record_name == &#34;HETATM&#34;:
    #                     current_residue = Residue(
    #                         residue_type=entry[&#34;res_name&#34;],
    #                         pdb_sequence_no=int(entry[&#34;res_seq&#34;]),
    #                         pdb_insertion_code=entry[&#34;icode&#34;],
    #                         chain=current_chain)
    #                     current_chain.add_residue(current_residue)
    #
    #                     # current_residue = current_chain.add_het_residue(
    #                     #     residue_type=entry[&#34;res_name&#34;],
    #                     #     sequence_no=int(entry[&#34;res_seq&#34;]),
    #                     #     insertion_code=entry[&#34;icode&#34;]
    #                     # )
    #
    #             # Temporary fix need to see if anything breaks (For Evo eg. 2HH1 -&gt; HH12)
    #             # Fix atom naming
    #             if entry[&#34;atom_name&#34;][0].isnumeric():
    #                 entry[&#34;atom_name&#34;] = entry[&#34;atom_name&#34;][1:] + entry[&#34;atom_name&#34;][0]
    #                 if entry[&#34;element&#34;] != &#34;H&#34;:
    #                     print(0)
    #                 if entry[&#34;atom_name&#34;][0] == &#34;H&#34;:
    #                     entry[&#34;element&#34;] = &#34;H&#34;
    #
    #             # Add the atom to the residue
    #             if entry[&#34;alt_loc&#34;] == &#34;&#34;:
    #                 atom_id = entry[&#34;atom_name&#34;]
    #             else:
    #                 atom_id = entry[&#34;atom_name&#34;] + &#34;_&#34; + entry[&#34;alt_loc&#34;]
    #             atom = Atom(
    #                 element=entry[&#34;element&#34;],
    #                 atom_type=entry[&#34;atom_name&#34;],
    #                 x=entry[&#34;x&#34;],
    #                 y=entry[&#34;y&#34;],
    #                 z=entry[&#34;z&#34;],
    #
    #                 pdb_serial=entry[&#34;serial&#34;],
    #                 pdb_alt_loc=entry[&#34;alt_loc&#34;],
    #                 pdb_occupancy=entry[&#34;occupancy&#34;],
    #                 pdb_temp_factor=entry[&#34;temp_factor&#34;],
    #                 pdb_assigned_charge=entry[&#34;assigned_charge&#34;],
    #                 pqr_calculated_charge=entry[&#34;calculated_charge&#34;],
    #                 pqr_radius=entry[&#34;radius&#34;],
    #
    #                 is_hetero=(record_name == &#34;HETATM&#34;),
    #
    #                 residue=current_residue
    #             )
    #             current_residue.add_atom(atom_id, atom)
    #
    #     # if seqres:
    #     #     for chain_id in seqres:
    #     #         if seqres[chain_id]:
    #     #             protein.chains[chain_id].sequence = seqres[chain_id]
    #
    #     # Housekeeping
    #     protein.set_residue_indexing()
    #
    #     return protein</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="protkit.file_io.pdb_io.PDBIO"><code class="flex name class">
<span>class <span class="ident">PDBIO</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PDBIO():
    # --------------------------------------------------------------------------------
    # MODEL
    # --------------------------------------------------------------------------------

    @staticmethod
    def parse_pdb_model_line(line: str):
        &#34;&#34;&#34;
        Parse a MODEL (start model) line from a PDB file.

        COLUMNS        DATA  TYPE    FIELD          DEFINITION
        ---------------------------------------------------------------------------------------
         1 -  6        Record name   &#34;MODEL &#34;
        11 - 14        Integer       serial         Model serial number.
        &#34;&#34;&#34;
        pdb_model_dict = {
            &#34;record_name&#34;: &#34;MODEL&#34;,
            &#34;serial&#34;: line[10:14]
        }

        return pdb_model_dict

    @staticmethod
    def create_pdb_model_line(serial: int):
        &#34;&#34;&#34;
        Creates a MODEL (start model) line for a PDB file.
        &#34;&#34;&#34;
        return &#34;MODEL&#34;.ljust(10) + str(serial).rjust(4) + &#34;&#34;.ljust(66)

    # --------------------------------------------------------------------------------
    # ENDMDL
    # --------------------------------------------------------------------------------

    @staticmethod
    def parse_pdb_end_model_line(line: str):
        &#34;&#34;&#34;
        Parse a ENDMDL (end model) line from a PDB file.

        COLUMNS       DATA  TYPE     FIELD        DEFINITION
        ------------------------------------------------------------------
        1 - 6         Record name   &#34;ENDMDL&#34;

        &#34;&#34;&#34;
        pdb_end_model_dict = {
            &#34;record_name&#34;: &#34;ENDMDL&#34;
        }

        return pdb_end_model_dict

    @staticmethod
    def create_pdb_end_model_line():
        &#34;&#34;&#34;
        Creates a ENDMDL (end model) line for a PDB file.
        &#34;&#34;&#34;
        return &#34;ENDMDL&#34;.ljust(80)

    # --------------------------------------------------------------------------------
    # MASTER
    # --------------------------------------------------------------------------------

    @staticmethod
    def create_pdb_master_line(num_atoms, num_hetatoms, num_ter, num_remark=0, num_het=0, num_helix=0, num_sheet=0,
                               num_site=0, num_trans=0, num_conect=0, num_seqres=0):
        &#34;&#34;&#34;
        Creates a MASTER (recordkeeping) line for a PDB file.

        COLUMNS         DATA TYPE     FIELD          DEFINITION
        ----------------------------------------------------------------------------------
         1 -  6         Record name   &#34;MASTER&#34;
        11 - 15         Integer       numRemark      Number of REMARK records
        16 - 20         Integer       &#34;0&#34;
        21 - 25         Integer       numHet         Number of HET records
        26 - 30         Integer       numHelix       Number of HELIX records
        31 - 35         Integer       numSheet       Number of SHEET records
        36 - 40         Integer       numTurn        deprecated
        41 - 45         Integer       numSite        Number of SITE records
        46 - 50         Integer       numXform       Number of coordinate transformation
                                                     records  (ORIGX+SCALE+MTRIX)
        51 - 55         Integer       numCoord       Number of atomic coordinate records
                                                     records (ATOM+HETATM)
        56 - 60         Integer       numTer         Number of TER records
        61 - 65         Integer       numConect      Number of CONECT records
        66 - 70         Integer       numSeq         Number of SEQRES records
        &#34;&#34;&#34;

        entries = [
            &#34;MASTER&#34;.ljust(10),
            str(num_remark).rjust(5),
            &#34;0&#34;.rjust(5),
            str(num_het).rjust(5),
            str(num_helix).rjust(5),
            str(num_sheet).rjust(5),
            &#34;0&#34;.rjust(5),
            str(num_site).rjust(5),
            str(num_trans).rjust(5),
            str(num_atoms + num_hetatoms).rjust(5),
            str(num_ter).rjust(5),
            str(num_conect).rjust(5),
            str(num_seqres).rjust(5),
            &#34;&#34;.ljust(10)
        ]

        return &#34;&#34;.join(entries)

    # --------------------------------------------------------------------------------
    # SEQRES
    # --------------------------------------------------------------------------------

    @staticmethod
    def parse_pdb_seqres_line(line: str):
        &#34;&#34;&#34;
        Parse a SEQRES (sequence) line from a PDB file.
        &#34;&#34;&#34;
        pdb_seqres_dict = {
            &#34;record_name&#34;: &#34;SEQRES&#34;,
            &#34;chain_id&#34;: line[11],
            &#34;residues&#34;: line[19:].strip().split()
        }

        return pdb_seqres_dict

    @staticmethod
    def create_seqres_line(line_no, chain_id, num_residues, residues):
        &#34;&#34;&#34;
        Creates a SEQRES (sequence) line for a PDB file.

         1 -  6        Record name    &#34;SEQRES&#34;
         8 - 10        Integer        serNum       Serial number of the SEQRES record for  the
                                                   current  chain. Starts at 1 and increments
                                                   by one  each line. Reset to 1 for each chain.
        12             Character      chainID      Chain identifier. This may be any single
                                                   legal  character, including a blank which
                                                   is used if there is only one chain.
        14 - 17        Integer        numRes       Number of residues in the chain.
                                                   This  value is repeated on every record.
        20 - 22        Residue name   resName      Residue name.
        24 - 26        Residue name   resName      Residue name.
        28 - 30        Residue name   resName      Residue name.
        32 - 34        Residue name   resName      Residue name.
        36 - 38        Residue name   resName      Residue name.
        40 - 42        Residue name   resName      Residue name.
        44 - 46        Residue name   resName      Residue name.
        48 - 50        Residue name   resName      Residue name.
        52 - 54        Residue name   resName      Residue name.
        56 - 58        Residue name   resName      Residue name.
        60 - 62        Residue name   resName      Residue name.
        64 - 66        Residue name   resName      Residue name.
        68 - 70        Residue name   resName      Residue name.
        &#34;&#34;&#34;
        entries = [
            &#34;SEQRES &#34;,
            str(line_no).rjust(3) + &#34; &#34;,
            chain_id + &#34; &#34;,
            str(num_residues).rjust(4) + &#34;  &#34;
        ]
        for residue in residues:
            entries.append(residue[&#34;residue&#34;].rjust(3) + &#34; &#34;)
        return &#34;&#34;.join(entries).ljust(80)

    # --------------------------------------------------------------------------------
    # TER
    # --------------------------------------------------------------------------------

    @staticmethod
    def parse_pdb_ter_line(line: str):
        &#34;&#34;&#34;
        Parse a TER (chain termination) line from a PDB file.

        COLUMNS        DATA  TYPE    FIELD           DEFINITION
        -------------------------------------------------------------------------
         1 -  6        Record name   &#34;TER   &#34;
         7 - 11        Integer       serial          Serial number.
        18 - 20        Residue name  resName         Residue name.
        22             Character     chainID         Chain identifier.
        23 - 26        Integer       resSeq          Residue sequence number.
        27             AChar         iCode           Insertion code.

        &#34;&#34;&#34;
        if line == &#34;TER&#34;:
            pdb_ter_dict = {
                &#34;record_name&#34;: &#34;TER&#34;,
                &#34;serial&#34;: &#34;&#34;,
                &#34;res_name&#34;: &#34;&#34;,
                &#34;chain_id&#34;: &#34;&#34;,
                &#34;res_seq&#34;: &#34;&#34;,
                &#34;icode&#34;: &#34;&#34;
            }
        else:
            line = line.ljust(80)
            pdb_ter_dict = {
                &#34;record_name&#34;: &#34;TER&#34;,
                &#34;serial&#34;: line[6:11],
                &#34;res_name&#34;: line[17:21],
                &#34;chain_id&#34;: line[21],
                &#34;res_seq&#34;: line[22:26],
                &#34;icode&#34;: line[26]
            }
        return pdb_ter_dict

    @staticmethod
    def create_pdb_ter_line(serial, res_name, chain_id, res_seq, icode):
        &#34;&#34;&#34;
        Creates a TER (chain termination) line for a PDB file.
        &#34;&#34;&#34;
        text = &#34;TER&#34;.ljust(6)
        text += str(serial).rjust(5) + &#34;      &#34;
        text += res_name.rjust(3) + &#34; &#34;
        text += chain_id
        text += res_seq.rjust(4)
        text += icode.ljust(1)

        return text.ljust(80)

    # --------------------------------------------------------------------------------
    # ATOM | HETATM
    # --------------------------------------------------------------------------------

    @staticmethod
    def parse_pdb_atom_line(line, is_pqr_format: bool = False):
        &#34;&#34;&#34;
        Parse a ATOM (individual atom) or HETATM (hetero atom) line from a PDB file.

        COLUMNS        DATA  TYPE    FIELD        DEFINITION
        -------------------------------------------------------------------------------------
         1 -  6        Record name   &#34;ATOM  &#34;
         7 - 11        Integer       serial       Atom  serial number.
        13 - 16        Atom          name         Atom name.
        17             Character     altLoc       Alternate location indicator.
        18 - 20        Residue name  resName      Residue name.
        22             Character     chainID      Chain identifier.
        23 - 26        Integer       resSeq       Residue sequence number.
        27             AChar         iCode        Code for insertion of residues.
        31 - 38        Real(8.3)     x            Orthogonal coordinates for X in Angstroms.
        39 - 46        Real(8.3)     y            Orthogonal coordinates for Y in Angstroms.
        47 - 54        Real(8.3)     z            Orthogonal coordinates for Z in Angstroms.
        55 - 60        Real(6.2)     occupancy    Occupancy.
        61 - 66        Real(6.2)     tempFactor   Temperature  factor.
        77 - 78        LString(2)    element      Element symbol, right-justified.
        79 - 80        LString(2)    charge       Charge  on the atom.`
        &#34;&#34;&#34;
        if not is_pqr_format:
            pdb_atom_dict = {
                &#34;record_name&#34;: line[0:6].strip().upper(),
                &#34;serial&#34;: line[6:11].strip(),
                # Open space
                &#34;atom_name&#34;: line[12:16].strip(),
                &#34;alt_loc&#34;: line[16].strip(),
                &#34;res_name&#34;: line[17:20].strip(),
                # Open space
                &#34;chain_id&#34;: line[21].strip(),
                &#34;res_seq&#34;: line[22:26].strip(),
                &#34;icode&#34;: line[26].strip(),
                # 3x Open space
                &#34;x&#34;: float(line[30:38]),
                &#34;y&#34;: float(line[38:46]),
                &#34;z&#34;: float(line[46:54]),
                &#34;occupancy&#34;: float(line[54:60]),
                # &#34;temp_factor&#34;: None,
                &#34;temp_factor&#34;: float(line[60:66]),
                # 66 - 75?
                &#34;element&#34;: line[76:78].strip(),
                &#34;assigned_charge&#34;: line[78:80].strip(),
                &#34;calculated_charge&#34;: None,
                &#34;radius&#34;: None
            }
        else:
            pdb_atom_dict = {
                &#34;record_name&#34;: line[0:6].strip().upper(),
                &#34;serial&#34;: line[6:11].strip(),
                # Open space
                &#34;atom_name&#34;: line[12:16].strip(),
                &#34;alt_loc&#34;: line[16].strip(),
                &#34;res_name&#34;: line[17:20].strip(),
                # Open space
                &#34;chain_id&#34;: line[21].strip(),
                &#34;res_seq&#34;: line[22:26].strip(),
                &#34;icode&#34;: line[26].strip(),
                # 3x Open space
                &#34;x&#34;: float(line[30:38]),
                &#34;y&#34;: float(line[38:46]),
                &#34;z&#34;: float(line[46:54]),

                &#34;occupancy&#34;: 1.0,
                &#34;temp_factor&#34;: None,

                &#34;element&#34;: line[76:78].strip(),
                &#34;assigned_charge&#34;: None,
                &#34;calculated_charge&#34;: float(line[54:62]),
                &#34;radius&#34;: float(line[62:70])
            }
        return pdb_atom_dict

    @staticmethod
    def create_pdb_atom_line(atom, serial: int, record_name=&#34;ATOM&#34;):
        &#34;&#34;&#34;
        Creates a ATOM line for a PDB file.

        The record_name is expected to be ATOM or HETATM
        &#34;&#34;&#34;
        # text = &#34;ATOM&#34;.ljust(6)
        # text += atom[&#34;serial&#34;].rjust(5) + &#34; &#34;
        text = record_name.ljust(6)
        text += str(serial).rjust(5) + &#34; &#34;

        # The PDB spec says that if the element has two characters, e.g. Fe (iron)
        # it should start at the position 13, otherwise it should start at position 14.
        # This seems a little problematic, as some atoms could use 4 characters
        # for example, HG11. The implementation here is consistent with observed PDBs
        # from the RCSB.
        if len(atom[&#34;element&#34;]) == 2 or len(atom[&#34;atom_name&#34;]) == 4:
            text += atom[&#34;atom_name&#34;].ljust(4)
        else:
            text += &#34; &#34; + atom[&#34;atom_name&#34;].ljust(3)
        text += (&#34;&#34; if atom[&#34;alt_loc&#34;] is None else atom[&#34;alt_loc&#34;]).ljust(1)
        text += atom[&#34;res_name&#34;].rjust(3) + &#34; &#34;
        text += atom[&#34;chain_id&#34;]
        text += atom[&#34;res_seq&#34;].rjust(4)
        text += atom[&#34;icode&#34;].ljust(1) + &#34;   &#34;
        text += f&#39;{atom[&#34;x&#34;]:8.3f}&#39;
        text += f&#39;{atom[&#34;y&#34;]:8.3f}&#39;
        text += f&#39;{atom[&#34;z&#34;]:8.3f}&#39;
        text += f&#39;{1.0 if atom[&#34;occupancy&#34;] is None else atom[&#34;occupancy&#34;]:6.2f}&#39;
        text += f&#39;{0.0 if atom[&#34;temp_factor&#34;] is None else atom[&#34;temp_factor&#34;]:6.2f}&#39;
        text += &#34;&#34;.ljust(10)
        text += atom[&#34;element&#34;].rjust(2)
        text += (&#34;&#34; if atom[&#34;charge&#34;] is None else atom[&#34;charge&#34;]).rjust(2)
        return text

    # --------------------------------------------------------------------------------
    # Main parsing and saving functions
    # --------------------------------------------------------------------------------

    @staticmethod
    def parse_pdb_entries(file_path: str, is_pqr_format: bool = False):
        &#34;&#34;&#34;
        Parse PDB file according to the spec provided at:
        https://www.wwpdb.org/documentation/file-format-content/format33/sect9.html#ATOM
        &#34;&#34;&#34;
        # Open the file and extract the individual lines.
        with open(file_path) as file:
            lines = file.read().split(&#34;\n&#34;)

        # Parse every line into dictionary information
        entries = []
        for line in lines:
            record_name = line[0:6].strip().upper()
            if record_name == &#34;ATOM&#34;:
                pdb_atom_dict = PDBIO.parse_pdb_atom_line(line)
                entries.append(pdb_atom_dict)
            elif record_name == &#34;HETATM&#34;:
                pdb_atom_dict = PDBIO.parse_pdb_atom_line(line, is_pqr_format=is_pqr_format)
                entries.append(pdb_atom_dict)
            elif record_name == &#34;TER&#34;:
                pdb_ter_dict = PDBIO.parse_pdb_ter_line(line)
                entries.append(pdb_ter_dict)
            elif record_name == &#34;MODEL&#34;:
                pdb_model_dict = PDBIO.parse_pdb_model_line(line)
                entries.append(pdb_model_dict)
            elif record_name == &#34;ENDMDL&#34;:
                pdb_end_model_dict = PDBIO.parse_pdb_end_model_line(line)
                entries.append(pdb_end_model_dict)
            elif record_name == &#34;SEQRES&#34;:
                pdb_seqres_dict = PDBIO.parse_pdb_seqres_line(line)
                entries.append(pdb_seqres_dict)
        return entries

    @staticmethod
    def load(file_path: str,
             is_pqr_format: bool = False,
             pdb_id: Optional[str] = None) -&gt; List[Protein]:

        protein = Protein(pdb_id=pdb_id)
        models = []
        seqres = {}
        current_model = None
        current_chain: Optional[Chain] = None
        current_chain_id = None
        current_residue: Optional[Residue] = None
        current_residue_id = None
        entries = PDBIO.parse_pdb_entries(file_path, is_pqr_format=is_pqr_format)

        for entry in entries:
            record_name = entry[&#34;record_name&#34;]
            if record_name == &#34;SEQRES&#34;:
                chain_id = entry[&#34;chain_id&#34;]
                if chain_id not in seqres:
                    seqres[chain_id] = []
                seqres[chain_id].extend(entry[&#34;residues&#34;])
            elif record_name == &#34;MODEL&#34;:
                # Usually, the MODEL field will only be found in structures based on NMR.
                # We only use the first model in a file if provided.
                # There is nothing to do, so we
                pass
            elif record_name == &#34;ENDMDL&#34;:
                # Usually, the ENDMDL field will only be found in structures based on NMR.
                # it closes a corresponding MODEL field.
                # Since the end of the model is reached, no more entries should be parsed.
                break
            elif record_name == &#34;TER&#34;:
                # The TER field terminates the current chain.
                current_chain = None
                current_chain_id = None
            elif record_name == &#34;ATOM&#34; or record_name == &#34;HETATM&#34;:
                # If we switched chains, set the chain.
                if entry[&#34;chain_id&#34;] != current_chain_id:
                    current_chain_id = entry[&#34;chain_id&#34;]
                    if protein.has_chain(current_chain_id):
                        current_chain = protein.get_chain(current_chain_id)
                    else:
                        current_chain = protein.create_chain(current_chain_id)

                # Check if the residue exists
                residue_id = current_chain_id + entry[&#34;res_seq&#34;] + entry[&#34;icode&#34;]
                if residue_id != current_residue_id:
                    current_residue_id = residue_id
                    if record_name == &#34;ATOM&#34;:
                        # if entry[&#34;res_name&#34;] in ResidueTemplate.VALID_DNA_RESIDUES:
                        #     current_residue = current_chain.add_dna_residue(
                        #         residue_type=entry[&#34;res_name&#34;],
                        #         sequence_no=int(entry[&#34;res_seq&#34;]),
                        #         insertion_code=entry[&#34;icode&#34;]
                        #     )
                        # else:
                        current_residue = Residue(
                            residue_type=entry[&#34;res_name&#34;],
                            sequence_no=int(entry[&#34;res_seq&#34;]),
                            insertion_code=entry[&#34;icode&#34;],
                            chain=current_chain)
                        current_chain.add_residue(current_residue)
                    elif record_name == &#34;HETATM&#34;:
                        current_residue = Residue(
                            residue_type=entry[&#34;res_name&#34;],
                            sequence_no=int(entry[&#34;res_seq&#34;]),
                            insertion_code=entry[&#34;icode&#34;],
                            chain=current_chain)
                        current_chain.add_residue(current_residue)

                        # current_residue = current_chain.add_het_residue(
                        #     residue_type=entry[&#34;res_name&#34;],
                        #     sequence_no=int(entry[&#34;res_seq&#34;]),
                        #     insertion_code=entry[&#34;icode&#34;]
                        # )

                # Temporary fix need to see if anything breaks (For Evo eg. 2HH1 -&gt; HH12)
                # Fix atom naming
                if entry[&#34;atom_name&#34;][0].isnumeric():
                    entry[&#34;atom_name&#34;] = entry[&#34;atom_name&#34;][1:] + entry[&#34;atom_name&#34;][0]
                    if entry[&#34;element&#34;] != &#34;H&#34;:
                        print(0)
                    if entry[&#34;atom_name&#34;][0] == &#34;H&#34;:
                        entry[&#34;element&#34;] = &#34;H&#34;

                # Add the atom to the residue
                # if entry[&#34;alt_loc&#34;] == &#34;&#34;:
                #     atom_id = entry[&#34;atom_name&#34;]
                # else:
                #     atom_id = entry[&#34;atom_name&#34;] + &#34;_&#34; + entry[&#34;alt_loc&#34;]
                atom = Atom(
                    element=entry[&#34;element&#34;],
                    atom_type=entry[&#34;atom_name&#34;],
                    x=entry[&#34;x&#34;],
                    y=entry[&#34;y&#34;],
                    z=entry[&#34;z&#34;],

                    # Serial is dependent on the atom ordering,
                    # so it is not used in the Atom class
                    # pdb_serial=entry[&#34;serial&#34;],
                    alt_loc=entry[&#34;alt_loc&#34;],
                    occupancy=entry[&#34;occupancy&#34;],
                    temp_factor=entry[&#34;temp_factor&#34;],
                    assigned_charge=entry[&#34;assigned_charge&#34;],
                    # pqr_calculated_charge=entry[&#34;calculated_charge&#34;],
                    # pqr_radius=entry[&#34;radius&#34;],
                    #
                    is_hetero=(record_name == &#34;HETATM&#34;),

                    residue=current_residue
                )

                # current_residue.add_atom(atom_id, atom)
                current_residue.add_atom(atom.atom_type, atom)

        if seqres:
            for chain_id in seqres:
                if seqres[chain_id]:
                    protein.get_chain(chain_id).set_attribute(&#34;seqres&#34;, seqres[chain_id])

        # Housekeeping
        # protein.set_residue_indexing()

        return [protein]

    @staticmethod
    def save(protein: Protein,
             file_path: str,
             is_pqr_format=False) -&gt; None:
        text_entries = []
        num_seqres = 0
        num_atoms = 0
        num_hetatoms = 0
        num_ter = 0
        serial = 1

        for chain in protein.chains:
            for residue in chain.residues:
                for atom in residue.atoms:
                    if not atom.is_hetero:
                        atom_entry = {
                            &#34;element&#34;: atom.element,
                            &#34;atom_name&#34;: atom.atom_type,
                            &#34;alt_loc&#34;: atom.get_attribute(&#34;pdb_alt_loc&#34;),
                            &#34;res_name&#34;: residue.residue_type,
                            &#34;chain_id&#34;: chain.chain_id,
                            &#34;res_seq&#34;: str(residue.sequence_no),
                            &#34;icode&#34;: residue.insertion_code,
                            &#34;x&#34;: atom.x,
                            &#34;y&#34;: atom.y,
                            &#34;z&#34;: atom.z,
                            &#34;occupancy&#34;: atom.get_attribute(&#34;occupancy&#34;),
                            # &#34;temp_factor&#34;: atom._pdb_temp_factor if atom._pdb_temp_factor is not None else 0.0,
                            &#34;temp_factor&#34;: atom.get_attribute(&#34;temp_factor&#34;),
                            &#34;charge&#34;: atom.get_attribute(&#34;assigned_charge&#34;)
                        }
                        text_entries.append(PDBIO.create_pdb_atom_line(atom_entry, serial))
                        serial += 1
                        num_atoms += 1

        # Bookkeeping records
        text_entries.append(PDBIO.create_pdb_master_line(num_atoms, num_hetatoms, num_ter, num_seqres=num_seqres))
        text_entries.append(&#34;END&#34;.ljust(80))

        with open(file_path, &#34;w&#34;) as file:
            file.write(&#34;\n&#34;.join(text_entries))

    # TODO: from_pdb_text and to_pdb_text was added by Claudio
    # The intent is that one should parse proteins from text
    # without working with files. However, a lot of code copying
    # was made and it need to be reworked significantly.

    @staticmethod
    def from_pdb_text(lines) -&gt; List[Protein]:
        lines = lines.split(&#34;\n&#34;)

        entries = []
        for line in lines:
            record_name = line[0:6].strip().upper()
            if record_name == &#34;ATOM&#34;:
                pdb_atom_dict = PDBIO.parse_pdb_atom_line(line)
                entries.append(pdb_atom_dict)
            elif record_name == &#34;HETATM&#34;:
                pdb_atom_dict = PDBIO.parse_pdb_atom_line(line)
                entries.append(pdb_atom_dict)
            elif record_name == &#34;TER&#34;:
                pdb_ter_dict = PDBIO.parse_pdb_ter_line(line)
                entries.append(pdb_ter_dict)
            elif record_name == &#34;MODEL&#34;:
                pdb_model_dict = PDBIO.parse_pdb_model_line(line)
                entries.append(pdb_model_dict)
            elif record_name == &#34;ENDMDL&#34;:
                pdb_end_model_dict = PDBIO.parse_pdb_end_model_line(line)
                entries.append(pdb_end_model_dict)
            elif record_name == &#34;SEQRES&#34;:
                pdb_seqres_dict = PDBIO.parse_pdb_seqres_line(line)
                entries.append(pdb_seqres_dict)

        protein = Protein()
        models = []
        seqres = {}
        current_model = None
        current_chain: Optional[Chain] = None
        current_chain_id = None
        current_residue: Optional[Residue] = None
        current_residue_id = None

        for entry in entries:
            record_name = entry[&#34;record_name&#34;]
            if record_name == &#34;SEQRES&#34;:
                chain_id = entry[&#34;chain_id&#34;]
                if chain_id not in seqres:
                    seqres[chain_id] = []
                seqres[chain_id].extend(entry[&#34;residues&#34;])
            elif record_name == &#34;MODEL&#34;:
                # Usually, the MODEL field will only be found in structures based on NMR.
                # We only use the first model in a file if provided.
                # There is nothing to do, so we
                pass
            elif record_name == &#34;ENDMDL&#34;:
                # Usually, the ENDMDL field will only be found in structures based on NMR.
                # it closes a corresponding MODEL field.
                # Since the end of the model is reached, no more entries should be parsed.
                break
            elif record_name == &#34;TER&#34;:
                # The TER field terminates the current chain.
                current_chain = None
                current_chain_id = None
            elif record_name == &#34;ATOM&#34; or record_name == &#34;HETATM&#34;:
                # If we switched chains, set the chain.
                if entry[&#34;chain_id&#34;] != current_chain_id:
                    current_chain_id = entry[&#34;chain_id&#34;]
                    if protein.has_chain(current_chain_id):
                        current_chain = protein.get_chain(current_chain_id)
                    else:
                        current_chain = protein.create_chain(current_chain_id)

                # Check if the residue exists
                residue_id = current_chain_id + entry[&#34;res_seq&#34;] + entry[&#34;icode&#34;]
                if residue_id != current_residue_id:
                    current_residue_id = residue_id
                    if record_name == &#34;ATOM&#34;:
                        # if entry[&#34;res_name&#34;] in ResidueTemplate.VALID_DNA_RESIDUES:
                        #     current_residue = current_chain.add_dna_residue(
                        #         residue_type=entry[&#34;res_name&#34;],
                        #         sequence_no=int(entry[&#34;res_seq&#34;]),
                        #         insertion_code=entry[&#34;icode&#34;]
                        #     )
                        # else:
                        current_residue = Residue(
                            residue_type=entry[&#34;res_name&#34;],
                            sequence_no=int(entry[&#34;res_seq&#34;]),
                            insertion_code=entry[&#34;icode&#34;],
                            chain=current_chain)
                        current_chain.add_residue(current_residue)
                    elif record_name == &#34;HETATM&#34;:
                        current_residue = Residue(
                            residue_type=entry[&#34;res_name&#34;],
                            sequence_no=int(entry[&#34;res_seq&#34;]),
                            insertion_code=entry[&#34;icode&#34;],
                            chain=current_chain)
                        current_chain.add_residue(current_residue)

                        # current_residue = current_chain.add_het_residue(
                        #     residue_type=entry[&#34;res_name&#34;],
                        #     sequence_no=int(entry[&#34;res_seq&#34;]),
                        #     insertion_code=entry[&#34;icode&#34;]
                        # )

                # Temporary fix need to see if anything breaks (For Evo eg. 2HH1 -&gt; HH12)
                # Fix atom naming
                if entry[&#34;atom_name&#34;][0].isnumeric():
                    entry[&#34;atom_name&#34;] = entry[&#34;atom_name&#34;][1:] + entry[&#34;atom_name&#34;][0]
                    if entry[&#34;element&#34;] != &#34;H&#34;:
                        print(0)
                    if entry[&#34;atom_name&#34;][0] == &#34;H&#34;:
                        entry[&#34;element&#34;] = &#34;H&#34;

                # Add the atom to the residue
                if entry[&#34;alt_loc&#34;] == &#34;&#34;:
                    atom_id = entry[&#34;atom_name&#34;]
                else:
                    atom_id = entry[&#34;atom_name&#34;] + &#34;_&#34; + entry[&#34;alt_loc&#34;]
                atom = Atom(
                    element=entry[&#34;element&#34;],
                    atom_type=entry[&#34;atom_name&#34;],
                    x=entry[&#34;x&#34;],
                    y=entry[&#34;y&#34;],
                    z=entry[&#34;z&#34;],

                    # pdb_serial=entry[&#34;serial&#34;],
                    # pdb_alt_loc=entry[&#34;alt_loc&#34;],
                    # pdb_occupancy=entry[&#34;occupancy&#34;],
                    # pdb_temp_factor=entry[&#34;temp_factor&#34;],
                    # pdb_assigned_charge=entry[&#34;assigned_charge&#34;],
                    # pqr_calculated_charge=entry[&#34;calculated_charge&#34;],
                    # pqr_radius=entry[&#34;radius&#34;],
                    #
                    is_hetero=(record_name == &#34;HETATM&#34;),

                    residue=current_residue
                )
                current_residue.add_atom(atom_id, atom)

        # if seqres:
        #     for chain_id in seqres:
        #         if seqres[chain_id]:
        #             protein.chains[chain_id].sequence = seqres[chain_id]

        # Housekeeping
        # protein.set_residue_indexing()

        return [protein]

    @staticmethod
    def to_pdb_text(protein: Protein):
        text_entries = &#34;&#34;
        num_seqres = 0
        num_atoms = 0
        num_hetatoms = 0
        num_ter = 0
        serial = 1

        for chain in protein.chains:
            for residue in chain.residues:
                for atom in residue.atoms:
                    if not atom.is_hetero:
                        atom_entry = {
                            &#34;element&#34;: atom.element,
                            &#34;atom_name&#34;: atom.atom_type,
                            &#34;alt_loc&#34;: atom.get_attribute(&#34;pdb_alt_loc&#34;),
                            &#34;res_name&#34;: residue.residue_type,
                            &#34;chain_id&#34;: chain.chain_id,
                            &#34;res_seq&#34;: str(residue.sequence_no),
                            &#34;icode&#34;: residue.insertion_code,
                            &#34;x&#34;: atom.x,
                            &#34;y&#34;: atom.y,
                            &#34;z&#34;: atom.z,
                            &#34;occupancy&#34;: atom.get_attribute(&#34;occupancy&#34;),
                            # &#34;temp_factor&#34;: atom._pdb_temp_factor if atom._pdb_temp_factor is not None else 0.0,
                            &#34;temp_factor&#34;: atom.get_attribute(&#34;temp_factor&#34;),
                            &#34;charge&#34;: atom.get_attribute(&#34;assigned_charge&#34;)
                        }
                        text_entries += PDBIO.create_pdb_atom_line(atom_entry, serial)
                        text_entries += &#34;\n&#34;
                        serial += 1
                        num_atoms += 1

        # Bookkeeping records
        text_entries += PDBIO.create_pdb_master_line(num_atoms, num_hetatoms, num_ter, num_seqres=num_seqres)
        text_entries += &#34;END&#34;.ljust(80)
        text_entries += &#34;\n&#34;

        return text_entries


    # @staticmethod
    # def save_to_pdb(file_path: str, protein):
    #     entries = []
    #
    #     num_seqres = 0
    #     num_atoms = 0
    #     num_hetatoms = 0
    #     num_ter = 0
    #     serial = 1
    #
    #     for chain in protein.chains:
    #         for residue in chain.residues:
    #             # ATOM entries
    #             for atom in residue.atoms:
    #                 if not atom.is_hetero:
    #                     atom_entry = {
    #                         &#34;element&#34;: atom.element,
    #                         &#34;atom_name&#34;: atom.atom_type,
    #                         &#34;alt_loc&#34;: atom._pdb_alt_loc,
    #                         &#34;res_name&#34;: residue.residue_type,
    #                         &#34;chain_id&#34;: chain.chain_id,
    #                         &#34;res_seq&#34;: str(residue._pdb_sequence_no),
    #                         &#34;icode&#34;: residue._pdb_insertion_code,
    #                         &#34;x&#34;: atom.x,
    #                         &#34;y&#34;: atom.y,
    #                         &#34;z&#34;: atom.z,
    #                         &#34;occupancy&#34;: atom._pdb_occupancy,
    #                         &#34;temp_factor&#34;: atom._pdb_temp_factor if atom._pdb_temp_factor is not None else 0.0,
    #                         &#34;charge&#34;: atom._pdb_assigned_charge
    #                     }
    #                     entries.append(PDBParser.create_pdb_atom_line(atom_entry, serial))
    #                     serial += 1
    #                     num_atoms += 1
    #
    #         # TER entry
    #         if chain.num_residues - chain.num_hetero_residues &gt; 0:
    #             entries.append(
    #                 PDBParser.create_pdb_ter_line(serial, atom_entry[&#34;res_name&#34;], chain.chain_id, atom_entry[&#34;res_seq&#34;],
    #                                               atom_entry[&#34;icode&#34;]))
    #             serial = serial + 1
    #             num_ter += 1
    #
    #     for chain in protein.chains:
    #         for residue in chain.residues:
    #             # HETATM entries
    #             for atom in residue.atoms:
    #                 if atom.is_hetero:
    #                     atom_entry = {
    #                         &#34;element&#34;: atom.element,
    #                         &#34;atom_name&#34;: atom.atom_type,
    #                         &#34;alt_loc&#34;: atom._pdb_alt_loc,
    #                         &#34;res_name&#34;: residue.residue_type,
    #                         &#34;chain_id&#34;: chain.chain_id,
    #                         &#34;res_seq&#34;: str(residue._pdb_sequence_no),
    #                         &#34;icode&#34;: residue._pdb_insertion_code,
    #                         &#34;x&#34;: atom.x,
    #                         &#34;y&#34;: atom.y,
    #                         &#34;z&#34;: atom.z,
    #                         &#34;occupancy&#34;: atom._pdb_occupancy,
    #                         &#34;temp_factor&#34;: atom._pdb_temp_factor if atom._pdb_temp_factor is not None else 0.0,
    #                         &#34;charge&#34;: atom._pdb_assigned_charge
    #                     }
    #                     entries.append(PDBParser.create_pdb_atom_line(atom_entry, serial, &#34;HETATM&#34;))
    #                     serial += 1
    #                     num_hetatoms += 1
    #
    #         # Hetero residues have no TER records, so no need to write a termination code.
    #
    #     # Bookkeeping records
    #     entries.append(PDBParser.create_pdb_master_line(num_atoms, num_hetatoms, num_ter, num_seqres=num_seqres))
    #     entries.append(&#34;END&#34;.ljust(80))
    #
    #     # Write file
    #     with open(file_path, &#34;w&#34;) as file:
    #         file.write(&#34;\n&#34;.join(entries))

    # @staticmethod
    # def load_from_pdb(file_path: str):
    #     entries = PDBParser.parse_pdb_entries(file_path)
    #
    #     protein = Protein()
    #     models = []
    #     seqres = {}
    #     current_model = None
    #     current_chain: Chain = None
    #     current_chain_id = None
    #     current_residue: Residue = None
    #     current_residue_id = None
    #
    #     for entry in entries:
    #         record_name = entry[&#34;record_name&#34;]
    #         if record_name == &#34;SEQRES&#34;:
    #             chain_id = entry[&#34;chain_id&#34;]
    #             if chain_id not in seqres:
    #                 seqres[chain_id] = []
    #             seqres[chain_id].extend(entry[&#34;residues&#34;])
    #         elif record_name == &#34;MODEL&#34;:
    #             # Usually, the MODEL field will only be found in structures based on NMR.
    #             # We only use the first model in a file if provided.
    #             # There is nothing to do, so we
    #             pass
    #         elif record_name == &#34;ENDMDL&#34;:
    #             # Usually, the ENDMDL field will only be found in structures based on NMR.
    #             # it closes a corresponding MODEL field.
    #             # Since the end of the model is reached, no more entries should be parsed.
    #             break
    #         elif record_name == &#34;TER&#34;:
    #             # The TER field terminates the current chain.
    #             current_chain = None
    #             current_chain_id = None
    #         elif record_name == &#34;ATOM&#34; or record_name == &#34;HETATM&#34;:
    #             # If we switched chains, set the chain.
    #             if entry[&#34;chain_id&#34;] != current_chain_id:
    #                 current_chain_id = entry[&#34;chain_id&#34;]
    #                 if current_chain_id in protein._chains:
    #                     current_chain = protein._chains[current_chain_id]
    #                 else:
    #                     current_chain = protein.create_chain(current_chain_id)
    #
    #             # Check if the residue exists
    #             residue_id = current_chain_id + entry[&#34;res_seq&#34;] + entry[&#34;icode&#34;]
    #             if residue_id != current_residue_id:
    #                 current_residue_id = residue_id
    #                 if record_name == &#34;ATOM&#34;:
    #                     # if entry[&#34;res_name&#34;] in ResidueTemplate.VALID_DNA_RESIDUES:
    #                     #     current_residue = current_chain.add_dna_residue(
    #                     #         residue_type=entry[&#34;res_name&#34;],
    #                     #         sequence_no=int(entry[&#34;res_seq&#34;]),
    #                     #         insertion_code=entry[&#34;icode&#34;]
    #                     #     )
    #                     # else:
    #                     current_residue = Residue(
    #                         residue_type=entry[&#34;res_name&#34;],
    #                         pdb_sequence_no=int(entry[&#34;res_seq&#34;]),
    #                         pdb_insertion_code=entry[&#34;icode&#34;],
    #                         chain=current_chain)
    #                     current_chain.add_residue(current_residue)
    #                 elif record_name == &#34;HETATM&#34;:
    #                     current_residue = Residue(
    #                         residue_type=entry[&#34;res_name&#34;],
    #                         pdb_sequence_no=int(entry[&#34;res_seq&#34;]),
    #                         pdb_insertion_code=entry[&#34;icode&#34;],
    #                         chain=current_chain)
    #                     current_chain.add_residue(current_residue)
    #
    #                     # current_residue = current_chain.add_het_residue(
    #                     #     residue_type=entry[&#34;res_name&#34;],
    #                     #     sequence_no=int(entry[&#34;res_seq&#34;]),
    #                     #     insertion_code=entry[&#34;icode&#34;]
    #                     # )
    #
    #             # Temporary fix need to see if anything breaks (For Evo eg. 2HH1 -&gt; HH12)
    #             # Fix atom naming
    #             if entry[&#34;atom_name&#34;][0].isnumeric():
    #                 entry[&#34;atom_name&#34;] = entry[&#34;atom_name&#34;][1:] + entry[&#34;atom_name&#34;][0]
    #                 if entry[&#34;element&#34;] != &#34;H&#34;:
    #                     print(0)
    #                 if entry[&#34;atom_name&#34;][0] == &#34;H&#34;:
    #                     entry[&#34;element&#34;] = &#34;H&#34;
    #
    #             # Add the atom to the residue
    #             if entry[&#34;alt_loc&#34;] == &#34;&#34;:
    #                 atom_id = entry[&#34;atom_name&#34;]
    #             else:
    #                 atom_id = entry[&#34;atom_name&#34;] + &#34;_&#34; + entry[&#34;alt_loc&#34;]
    #             atom = Atom(
    #                 element=entry[&#34;element&#34;],
    #                 atom_type=entry[&#34;atom_name&#34;],
    #                 x=entry[&#34;x&#34;],
    #                 y=entry[&#34;y&#34;],
    #                 z=entry[&#34;z&#34;],
    #
    #                 pdb_serial=entry[&#34;serial&#34;],
    #                 pdb_alt_loc=entry[&#34;alt_loc&#34;],
    #                 pdb_occupancy=entry[&#34;occupancy&#34;],
    #                 pdb_temp_factor=entry[&#34;temp_factor&#34;],
    #                 pdb_assigned_charge=entry[&#34;assigned_charge&#34;],
    #                 pqr_calculated_charge=entry[&#34;calculated_charge&#34;],
    #                 pqr_radius=entry[&#34;radius&#34;],
    #
    #                 is_hetero=(record_name == &#34;HETATM&#34;),
    #
    #                 residue=current_residue
    #             )
    #             current_residue.add_atom(atom_id, atom)
    #
    #     # if seqres:
    #     #     for chain_id in seqres:
    #     #         if seqres[chain_id]:
    #     #             protein.chains[chain_id].sequence = seqres[chain_id]
    #
    #     # Housekeeping
    #     protein.set_residue_indexing()
    #
    #     return protein</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="protkit.file_io.pdb_io.PDBIO.create_pdb_atom_line"><code class="name flex">
<span>def <span class="ident">create_pdb_atom_line</span></span>(<span>atom, serial:Â int, record_name='ATOM')</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a ATOM line for a PDB file.</p>
<p>The record_name is expected to be ATOM or HETATM</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_pdb_atom_line(atom, serial: int, record_name=&#34;ATOM&#34;):
    &#34;&#34;&#34;
    Creates a ATOM line for a PDB file.

    The record_name is expected to be ATOM or HETATM
    &#34;&#34;&#34;
    # text = &#34;ATOM&#34;.ljust(6)
    # text += atom[&#34;serial&#34;].rjust(5) + &#34; &#34;
    text = record_name.ljust(6)
    text += str(serial).rjust(5) + &#34; &#34;

    # The PDB spec says that if the element has two characters, e.g. Fe (iron)
    # it should start at the position 13, otherwise it should start at position 14.
    # This seems a little problematic, as some atoms could use 4 characters
    # for example, HG11. The implementation here is consistent with observed PDBs
    # from the RCSB.
    if len(atom[&#34;element&#34;]) == 2 or len(atom[&#34;atom_name&#34;]) == 4:
        text += atom[&#34;atom_name&#34;].ljust(4)
    else:
        text += &#34; &#34; + atom[&#34;atom_name&#34;].ljust(3)
    text += (&#34;&#34; if atom[&#34;alt_loc&#34;] is None else atom[&#34;alt_loc&#34;]).ljust(1)
    text += atom[&#34;res_name&#34;].rjust(3) + &#34; &#34;
    text += atom[&#34;chain_id&#34;]
    text += atom[&#34;res_seq&#34;].rjust(4)
    text += atom[&#34;icode&#34;].ljust(1) + &#34;   &#34;
    text += f&#39;{atom[&#34;x&#34;]:8.3f}&#39;
    text += f&#39;{atom[&#34;y&#34;]:8.3f}&#39;
    text += f&#39;{atom[&#34;z&#34;]:8.3f}&#39;
    text += f&#39;{1.0 if atom[&#34;occupancy&#34;] is None else atom[&#34;occupancy&#34;]:6.2f}&#39;
    text += f&#39;{0.0 if atom[&#34;temp_factor&#34;] is None else atom[&#34;temp_factor&#34;]:6.2f}&#39;
    text += &#34;&#34;.ljust(10)
    text += atom[&#34;element&#34;].rjust(2)
    text += (&#34;&#34; if atom[&#34;charge&#34;] is None else atom[&#34;charge&#34;]).rjust(2)
    return text</code></pre>
</details>
</dd>
<dt id="protkit.file_io.pdb_io.PDBIO.create_pdb_end_model_line"><code class="name flex">
<span>def <span class="ident">create_pdb_end_model_line</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a ENDMDL (end model) line for a PDB file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_pdb_end_model_line():
    &#34;&#34;&#34;
    Creates a ENDMDL (end model) line for a PDB file.
    &#34;&#34;&#34;
    return &#34;ENDMDL&#34;.ljust(80)</code></pre>
</details>
</dd>
<dt id="protkit.file_io.pdb_io.PDBIO.create_pdb_master_line"><code class="name flex">
<span>def <span class="ident">create_pdb_master_line</span></span>(<span>num_atoms, num_hetatoms, num_ter, num_remark=0, num_het=0, num_helix=0, num_sheet=0, num_site=0, num_trans=0, num_conect=0, num_seqres=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a MASTER (recordkeeping) line for a PDB file.</p>
<h2 id="columns-data-type-field-definition">Columns
Data Type
Field
Definition</h2>
<p>1 -
6
Record name
"MASTER"
11 - 15
Integer
numRemark
Number of REMARK records
16 - 20
Integer
"0"
21 - 25
Integer
numHet
Number of HET records
26 - 30
Integer
numHelix
Number of HELIX records
31 - 35
Integer
numSheet
Number of SHEET records
36 - 40
Integer
numTurn
deprecated
41 - 45
Integer
numSite
Number of SITE records
46 - 50
Integer
numXform
Number of coordinate transformation
records
(ORIGX+SCALE+MTRIX)
51 - 55
Integer
numCoord
Number of atomic coordinate records
records (ATOM+HETATM)
56 - 60
Integer
numTer
Number of TER records
61 - 65
Integer
numConect
Number of CONECT records
66 - 70
Integer
numSeq
Number of SEQRES records</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_pdb_master_line(num_atoms, num_hetatoms, num_ter, num_remark=0, num_het=0, num_helix=0, num_sheet=0,
                           num_site=0, num_trans=0, num_conect=0, num_seqres=0):
    &#34;&#34;&#34;
    Creates a MASTER (recordkeeping) line for a PDB file.

    COLUMNS         DATA TYPE     FIELD          DEFINITION
    ----------------------------------------------------------------------------------
     1 -  6         Record name   &#34;MASTER&#34;
    11 - 15         Integer       numRemark      Number of REMARK records
    16 - 20         Integer       &#34;0&#34;
    21 - 25         Integer       numHet         Number of HET records
    26 - 30         Integer       numHelix       Number of HELIX records
    31 - 35         Integer       numSheet       Number of SHEET records
    36 - 40         Integer       numTurn        deprecated
    41 - 45         Integer       numSite        Number of SITE records
    46 - 50         Integer       numXform       Number of coordinate transformation
                                                 records  (ORIGX+SCALE+MTRIX)
    51 - 55         Integer       numCoord       Number of atomic coordinate records
                                                 records (ATOM+HETATM)
    56 - 60         Integer       numTer         Number of TER records
    61 - 65         Integer       numConect      Number of CONECT records
    66 - 70         Integer       numSeq         Number of SEQRES records
    &#34;&#34;&#34;

    entries = [
        &#34;MASTER&#34;.ljust(10),
        str(num_remark).rjust(5),
        &#34;0&#34;.rjust(5),
        str(num_het).rjust(5),
        str(num_helix).rjust(5),
        str(num_sheet).rjust(5),
        &#34;0&#34;.rjust(5),
        str(num_site).rjust(5),
        str(num_trans).rjust(5),
        str(num_atoms + num_hetatoms).rjust(5),
        str(num_ter).rjust(5),
        str(num_conect).rjust(5),
        str(num_seqres).rjust(5),
        &#34;&#34;.ljust(10)
    ]

    return &#34;&#34;.join(entries)</code></pre>
</details>
</dd>
<dt id="protkit.file_io.pdb_io.PDBIO.create_pdb_model_line"><code class="name flex">
<span>def <span class="ident">create_pdb_model_line</span></span>(<span>serial:Â int)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a MODEL (start model) line for a PDB file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_pdb_model_line(serial: int):
    &#34;&#34;&#34;
    Creates a MODEL (start model) line for a PDB file.
    &#34;&#34;&#34;
    return &#34;MODEL&#34;.ljust(10) + str(serial).rjust(4) + &#34;&#34;.ljust(66)</code></pre>
</details>
</dd>
<dt id="protkit.file_io.pdb_io.PDBIO.create_pdb_ter_line"><code class="name flex">
<span>def <span class="ident">create_pdb_ter_line</span></span>(<span>serial, res_name, chain_id, res_seq, icode)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a TER (chain termination) line for a PDB file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_pdb_ter_line(serial, res_name, chain_id, res_seq, icode):
    &#34;&#34;&#34;
    Creates a TER (chain termination) line for a PDB file.
    &#34;&#34;&#34;
    text = &#34;TER&#34;.ljust(6)
    text += str(serial).rjust(5) + &#34;      &#34;
    text += res_name.rjust(3) + &#34; &#34;
    text += chain_id
    text += res_seq.rjust(4)
    text += icode.ljust(1)

    return text.ljust(80)</code></pre>
</details>
</dd>
<dt id="protkit.file_io.pdb_io.PDBIO.create_seqres_line"><code class="name flex">
<span>def <span class="ident">create_seqres_line</span></span>(<span>line_no, chain_id, num_residues, residues)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a SEQRES (sequence) line for a PDB file.</p>
<p>1 -
6
Record name
"SEQRES"
8 - 10
Integer
serNum
Serial number of the SEQRES record for
the
current
chain. Starts at 1 and increments
by one
each line. Reset to 1 for each chain.
12
Character
chainID
Chain identifier. This may be any single
legal
character, including a blank which
is used if there is only one chain.
14 - 17
Integer
numRes
Number of residues in the chain.
This
value is repeated on every record.
20 - 22
Residue name
resName
Residue name.
24 - 26
Residue name
resName
Residue name.
28 - 30
Residue name
resName
Residue name.
32 - 34
Residue name
resName
Residue name.
36 - 38
Residue name
resName
Residue name.
40 - 42
Residue name
resName
Residue name.
44 - 46
Residue name
resName
Residue name.
48 - 50
Residue name
resName
Residue name.
52 - 54
Residue name
resName
Residue name.
56 - 58
Residue name
resName
Residue name.
60 - 62
Residue name
resName
Residue name.
64 - 66
Residue name
resName
Residue name.
68 - 70
Residue name
resName
Residue name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_seqres_line(line_no, chain_id, num_residues, residues):
    &#34;&#34;&#34;
    Creates a SEQRES (sequence) line for a PDB file.

     1 -  6        Record name    &#34;SEQRES&#34;
     8 - 10        Integer        serNum       Serial number of the SEQRES record for  the
                                               current  chain. Starts at 1 and increments
                                               by one  each line. Reset to 1 for each chain.
    12             Character      chainID      Chain identifier. This may be any single
                                               legal  character, including a blank which
                                               is used if there is only one chain.
    14 - 17        Integer        numRes       Number of residues in the chain.
                                               This  value is repeated on every record.
    20 - 22        Residue name   resName      Residue name.
    24 - 26        Residue name   resName      Residue name.
    28 - 30        Residue name   resName      Residue name.
    32 - 34        Residue name   resName      Residue name.
    36 - 38        Residue name   resName      Residue name.
    40 - 42        Residue name   resName      Residue name.
    44 - 46        Residue name   resName      Residue name.
    48 - 50        Residue name   resName      Residue name.
    52 - 54        Residue name   resName      Residue name.
    56 - 58        Residue name   resName      Residue name.
    60 - 62        Residue name   resName      Residue name.
    64 - 66        Residue name   resName      Residue name.
    68 - 70        Residue name   resName      Residue name.
    &#34;&#34;&#34;
    entries = [
        &#34;SEQRES &#34;,
        str(line_no).rjust(3) + &#34; &#34;,
        chain_id + &#34; &#34;,
        str(num_residues).rjust(4) + &#34;  &#34;
    ]
    for residue in residues:
        entries.append(residue[&#34;residue&#34;].rjust(3) + &#34; &#34;)
    return &#34;&#34;.join(entries).ljust(80)</code></pre>
</details>
</dd>
<dt id="protkit.file_io.pdb_io.PDBIO.from_pdb_text"><code class="name flex">
<span>def <span class="ident">from_pdb_text</span></span>(<span>lines) â€‘>Â List[<a title="protkit.structure.protein.Protein" href="../structure/protein.html#protkit.structure.protein.Protein">Protein</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_pdb_text(lines) -&gt; List[Protein]:
    lines = lines.split(&#34;\n&#34;)

    entries = []
    for line in lines:
        record_name = line[0:6].strip().upper()
        if record_name == &#34;ATOM&#34;:
            pdb_atom_dict = PDBIO.parse_pdb_atom_line(line)
            entries.append(pdb_atom_dict)
        elif record_name == &#34;HETATM&#34;:
            pdb_atom_dict = PDBIO.parse_pdb_atom_line(line)
            entries.append(pdb_atom_dict)
        elif record_name == &#34;TER&#34;:
            pdb_ter_dict = PDBIO.parse_pdb_ter_line(line)
            entries.append(pdb_ter_dict)
        elif record_name == &#34;MODEL&#34;:
            pdb_model_dict = PDBIO.parse_pdb_model_line(line)
            entries.append(pdb_model_dict)
        elif record_name == &#34;ENDMDL&#34;:
            pdb_end_model_dict = PDBIO.parse_pdb_end_model_line(line)
            entries.append(pdb_end_model_dict)
        elif record_name == &#34;SEQRES&#34;:
            pdb_seqres_dict = PDBIO.parse_pdb_seqres_line(line)
            entries.append(pdb_seqres_dict)

    protein = Protein()
    models = []
    seqres = {}
    current_model = None
    current_chain: Optional[Chain] = None
    current_chain_id = None
    current_residue: Optional[Residue] = None
    current_residue_id = None

    for entry in entries:
        record_name = entry[&#34;record_name&#34;]
        if record_name == &#34;SEQRES&#34;:
            chain_id = entry[&#34;chain_id&#34;]
            if chain_id not in seqres:
                seqres[chain_id] = []
            seqres[chain_id].extend(entry[&#34;residues&#34;])
        elif record_name == &#34;MODEL&#34;:
            # Usually, the MODEL field will only be found in structures based on NMR.
            # We only use the first model in a file if provided.
            # There is nothing to do, so we
            pass
        elif record_name == &#34;ENDMDL&#34;:
            # Usually, the ENDMDL field will only be found in structures based on NMR.
            # it closes a corresponding MODEL field.
            # Since the end of the model is reached, no more entries should be parsed.
            break
        elif record_name == &#34;TER&#34;:
            # The TER field terminates the current chain.
            current_chain = None
            current_chain_id = None
        elif record_name == &#34;ATOM&#34; or record_name == &#34;HETATM&#34;:
            # If we switched chains, set the chain.
            if entry[&#34;chain_id&#34;] != current_chain_id:
                current_chain_id = entry[&#34;chain_id&#34;]
                if protein.has_chain(current_chain_id):
                    current_chain = protein.get_chain(current_chain_id)
                else:
                    current_chain = protein.create_chain(current_chain_id)

            # Check if the residue exists
            residue_id = current_chain_id + entry[&#34;res_seq&#34;] + entry[&#34;icode&#34;]
            if residue_id != current_residue_id:
                current_residue_id = residue_id
                if record_name == &#34;ATOM&#34;:
                    # if entry[&#34;res_name&#34;] in ResidueTemplate.VALID_DNA_RESIDUES:
                    #     current_residue = current_chain.add_dna_residue(
                    #         residue_type=entry[&#34;res_name&#34;],
                    #         sequence_no=int(entry[&#34;res_seq&#34;]),
                    #         insertion_code=entry[&#34;icode&#34;]
                    #     )
                    # else:
                    current_residue = Residue(
                        residue_type=entry[&#34;res_name&#34;],
                        sequence_no=int(entry[&#34;res_seq&#34;]),
                        insertion_code=entry[&#34;icode&#34;],
                        chain=current_chain)
                    current_chain.add_residue(current_residue)
                elif record_name == &#34;HETATM&#34;:
                    current_residue = Residue(
                        residue_type=entry[&#34;res_name&#34;],
                        sequence_no=int(entry[&#34;res_seq&#34;]),
                        insertion_code=entry[&#34;icode&#34;],
                        chain=current_chain)
                    current_chain.add_residue(current_residue)

                    # current_residue = current_chain.add_het_residue(
                    #     residue_type=entry[&#34;res_name&#34;],
                    #     sequence_no=int(entry[&#34;res_seq&#34;]),
                    #     insertion_code=entry[&#34;icode&#34;]
                    # )

            # Temporary fix need to see if anything breaks (For Evo eg. 2HH1 -&gt; HH12)
            # Fix atom naming
            if entry[&#34;atom_name&#34;][0].isnumeric():
                entry[&#34;atom_name&#34;] = entry[&#34;atom_name&#34;][1:] + entry[&#34;atom_name&#34;][0]
                if entry[&#34;element&#34;] != &#34;H&#34;:
                    print(0)
                if entry[&#34;atom_name&#34;][0] == &#34;H&#34;:
                    entry[&#34;element&#34;] = &#34;H&#34;

            # Add the atom to the residue
            if entry[&#34;alt_loc&#34;] == &#34;&#34;:
                atom_id = entry[&#34;atom_name&#34;]
            else:
                atom_id = entry[&#34;atom_name&#34;] + &#34;_&#34; + entry[&#34;alt_loc&#34;]
            atom = Atom(
                element=entry[&#34;element&#34;],
                atom_type=entry[&#34;atom_name&#34;],
                x=entry[&#34;x&#34;],
                y=entry[&#34;y&#34;],
                z=entry[&#34;z&#34;],

                # pdb_serial=entry[&#34;serial&#34;],
                # pdb_alt_loc=entry[&#34;alt_loc&#34;],
                # pdb_occupancy=entry[&#34;occupancy&#34;],
                # pdb_temp_factor=entry[&#34;temp_factor&#34;],
                # pdb_assigned_charge=entry[&#34;assigned_charge&#34;],
                # pqr_calculated_charge=entry[&#34;calculated_charge&#34;],
                # pqr_radius=entry[&#34;radius&#34;],
                #
                is_hetero=(record_name == &#34;HETATM&#34;),

                residue=current_residue
            )
            current_residue.add_atom(atom_id, atom)

    # if seqres:
    #     for chain_id in seqres:
    #         if seqres[chain_id]:
    #             protein.chains[chain_id].sequence = seqres[chain_id]

    # Housekeeping
    # protein.set_residue_indexing()

    return [protein]</code></pre>
</details>
</dd>
<dt id="protkit.file_io.pdb_io.PDBIO.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>file_path:Â str, is_pqr_format:Â boolÂ =Â False, pdb_id:Â Optional[str]Â =Â None) â€‘>Â List[<a title="protkit.structure.protein.Protein" href="../structure/protein.html#protkit.structure.protein.Protein">Protein</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def load(file_path: str,
         is_pqr_format: bool = False,
         pdb_id: Optional[str] = None) -&gt; List[Protein]:

    protein = Protein(pdb_id=pdb_id)
    models = []
    seqres = {}
    current_model = None
    current_chain: Optional[Chain] = None
    current_chain_id = None
    current_residue: Optional[Residue] = None
    current_residue_id = None
    entries = PDBIO.parse_pdb_entries(file_path, is_pqr_format=is_pqr_format)

    for entry in entries:
        record_name = entry[&#34;record_name&#34;]
        if record_name == &#34;SEQRES&#34;:
            chain_id = entry[&#34;chain_id&#34;]
            if chain_id not in seqres:
                seqres[chain_id] = []
            seqres[chain_id].extend(entry[&#34;residues&#34;])
        elif record_name == &#34;MODEL&#34;:
            # Usually, the MODEL field will only be found in structures based on NMR.
            # We only use the first model in a file if provided.
            # There is nothing to do, so we
            pass
        elif record_name == &#34;ENDMDL&#34;:
            # Usually, the ENDMDL field will only be found in structures based on NMR.
            # it closes a corresponding MODEL field.
            # Since the end of the model is reached, no more entries should be parsed.
            break
        elif record_name == &#34;TER&#34;:
            # The TER field terminates the current chain.
            current_chain = None
            current_chain_id = None
        elif record_name == &#34;ATOM&#34; or record_name == &#34;HETATM&#34;:
            # If we switched chains, set the chain.
            if entry[&#34;chain_id&#34;] != current_chain_id:
                current_chain_id = entry[&#34;chain_id&#34;]
                if protein.has_chain(current_chain_id):
                    current_chain = protein.get_chain(current_chain_id)
                else:
                    current_chain = protein.create_chain(current_chain_id)

            # Check if the residue exists
            residue_id = current_chain_id + entry[&#34;res_seq&#34;] + entry[&#34;icode&#34;]
            if residue_id != current_residue_id:
                current_residue_id = residue_id
                if record_name == &#34;ATOM&#34;:
                    # if entry[&#34;res_name&#34;] in ResidueTemplate.VALID_DNA_RESIDUES:
                    #     current_residue = current_chain.add_dna_residue(
                    #         residue_type=entry[&#34;res_name&#34;],
                    #         sequence_no=int(entry[&#34;res_seq&#34;]),
                    #         insertion_code=entry[&#34;icode&#34;]
                    #     )
                    # else:
                    current_residue = Residue(
                        residue_type=entry[&#34;res_name&#34;],
                        sequence_no=int(entry[&#34;res_seq&#34;]),
                        insertion_code=entry[&#34;icode&#34;],
                        chain=current_chain)
                    current_chain.add_residue(current_residue)
                elif record_name == &#34;HETATM&#34;:
                    current_residue = Residue(
                        residue_type=entry[&#34;res_name&#34;],
                        sequence_no=int(entry[&#34;res_seq&#34;]),
                        insertion_code=entry[&#34;icode&#34;],
                        chain=current_chain)
                    current_chain.add_residue(current_residue)

                    # current_residue = current_chain.add_het_residue(
                    #     residue_type=entry[&#34;res_name&#34;],
                    #     sequence_no=int(entry[&#34;res_seq&#34;]),
                    #     insertion_code=entry[&#34;icode&#34;]
                    # )

            # Temporary fix need to see if anything breaks (For Evo eg. 2HH1 -&gt; HH12)
            # Fix atom naming
            if entry[&#34;atom_name&#34;][0].isnumeric():
                entry[&#34;atom_name&#34;] = entry[&#34;atom_name&#34;][1:] + entry[&#34;atom_name&#34;][0]
                if entry[&#34;element&#34;] != &#34;H&#34;:
                    print(0)
                if entry[&#34;atom_name&#34;][0] == &#34;H&#34;:
                    entry[&#34;element&#34;] = &#34;H&#34;

            # Add the atom to the residue
            # if entry[&#34;alt_loc&#34;] == &#34;&#34;:
            #     atom_id = entry[&#34;atom_name&#34;]
            # else:
            #     atom_id = entry[&#34;atom_name&#34;] + &#34;_&#34; + entry[&#34;alt_loc&#34;]
            atom = Atom(
                element=entry[&#34;element&#34;],
                atom_type=entry[&#34;atom_name&#34;],
                x=entry[&#34;x&#34;],
                y=entry[&#34;y&#34;],
                z=entry[&#34;z&#34;],

                # Serial is dependent on the atom ordering,
                # so it is not used in the Atom class
                # pdb_serial=entry[&#34;serial&#34;],
                alt_loc=entry[&#34;alt_loc&#34;],
                occupancy=entry[&#34;occupancy&#34;],
                temp_factor=entry[&#34;temp_factor&#34;],
                assigned_charge=entry[&#34;assigned_charge&#34;],
                # pqr_calculated_charge=entry[&#34;calculated_charge&#34;],
                # pqr_radius=entry[&#34;radius&#34;],
                #
                is_hetero=(record_name == &#34;HETATM&#34;),

                residue=current_residue
            )

            # current_residue.add_atom(atom_id, atom)
            current_residue.add_atom(atom.atom_type, atom)

    if seqres:
        for chain_id in seqres:
            if seqres[chain_id]:
                protein.get_chain(chain_id).set_attribute(&#34;seqres&#34;, seqres[chain_id])

    # Housekeeping
    # protein.set_residue_indexing()

    return [protein]</code></pre>
</details>
</dd>
<dt id="protkit.file_io.pdb_io.PDBIO.parse_pdb_atom_line"><code class="name flex">
<span>def <span class="ident">parse_pdb_atom_line</span></span>(<span>line, is_pqr_format:Â boolÂ =Â False)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a ATOM (individual atom) or HETATM (hetero atom) line from a PDB file.</p>
<h2 id="columns-data-type-field-definition">Columns
Data
Type
Field
Definition</h2>
<p>1 -
6
Record name
"ATOM
"
7 - 11
Integer
serial
Atom
serial number.
13 - 16
Atom
name
Atom name.
17
Character
altLoc
Alternate location indicator.
18 - 20
Residue name
resName
Residue name.
22
Character
chainID
Chain identifier.
23 - 26
Integer
resSeq
Residue sequence number.
27
AChar
iCode
Code for insertion of residues.
31 - 38
Real(8.3)
x
Orthogonal coordinates for X in Angstroms.
39 - 46
Real(8.3)
y
Orthogonal coordinates for Y in Angstroms.
47 - 54
Real(8.3)
z
Orthogonal coordinates for Z in Angstroms.
55 - 60
Real(6.2)
occupancy
Occupancy.
61 - 66
Real(6.2)
tempFactor
Temperature
factor.
77 - 78
LString(2)
element
Element symbol, right-justified.
79 - 80
LString(2)
charge
Charge
on the atom.`</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse_pdb_atom_line(line, is_pqr_format: bool = False):
    &#34;&#34;&#34;
    Parse a ATOM (individual atom) or HETATM (hetero atom) line from a PDB file.

    COLUMNS        DATA  TYPE    FIELD        DEFINITION
    -------------------------------------------------------------------------------------
     1 -  6        Record name   &#34;ATOM  &#34;
     7 - 11        Integer       serial       Atom  serial number.
    13 - 16        Atom          name         Atom name.
    17             Character     altLoc       Alternate location indicator.
    18 - 20        Residue name  resName      Residue name.
    22             Character     chainID      Chain identifier.
    23 - 26        Integer       resSeq       Residue sequence number.
    27             AChar         iCode        Code for insertion of residues.
    31 - 38        Real(8.3)     x            Orthogonal coordinates for X in Angstroms.
    39 - 46        Real(8.3)     y            Orthogonal coordinates for Y in Angstroms.
    47 - 54        Real(8.3)     z            Orthogonal coordinates for Z in Angstroms.
    55 - 60        Real(6.2)     occupancy    Occupancy.
    61 - 66        Real(6.2)     tempFactor   Temperature  factor.
    77 - 78        LString(2)    element      Element symbol, right-justified.
    79 - 80        LString(2)    charge       Charge  on the atom.`
    &#34;&#34;&#34;
    if not is_pqr_format:
        pdb_atom_dict = {
            &#34;record_name&#34;: line[0:6].strip().upper(),
            &#34;serial&#34;: line[6:11].strip(),
            # Open space
            &#34;atom_name&#34;: line[12:16].strip(),
            &#34;alt_loc&#34;: line[16].strip(),
            &#34;res_name&#34;: line[17:20].strip(),
            # Open space
            &#34;chain_id&#34;: line[21].strip(),
            &#34;res_seq&#34;: line[22:26].strip(),
            &#34;icode&#34;: line[26].strip(),
            # 3x Open space
            &#34;x&#34;: float(line[30:38]),
            &#34;y&#34;: float(line[38:46]),
            &#34;z&#34;: float(line[46:54]),
            &#34;occupancy&#34;: float(line[54:60]),
            # &#34;temp_factor&#34;: None,
            &#34;temp_factor&#34;: float(line[60:66]),
            # 66 - 75?
            &#34;element&#34;: line[76:78].strip(),
            &#34;assigned_charge&#34;: line[78:80].strip(),
            &#34;calculated_charge&#34;: None,
            &#34;radius&#34;: None
        }
    else:
        pdb_atom_dict = {
            &#34;record_name&#34;: line[0:6].strip().upper(),
            &#34;serial&#34;: line[6:11].strip(),
            # Open space
            &#34;atom_name&#34;: line[12:16].strip(),
            &#34;alt_loc&#34;: line[16].strip(),
            &#34;res_name&#34;: line[17:20].strip(),
            # Open space
            &#34;chain_id&#34;: line[21].strip(),
            &#34;res_seq&#34;: line[22:26].strip(),
            &#34;icode&#34;: line[26].strip(),
            # 3x Open space
            &#34;x&#34;: float(line[30:38]),
            &#34;y&#34;: float(line[38:46]),
            &#34;z&#34;: float(line[46:54]),

            &#34;occupancy&#34;: 1.0,
            &#34;temp_factor&#34;: None,

            &#34;element&#34;: line[76:78].strip(),
            &#34;assigned_charge&#34;: None,
            &#34;calculated_charge&#34;: float(line[54:62]),
            &#34;radius&#34;: float(line[62:70])
        }
    return pdb_atom_dict</code></pre>
</details>
</dd>
<dt id="protkit.file_io.pdb_io.PDBIO.parse_pdb_end_model_line"><code class="name flex">
<span>def <span class="ident">parse_pdb_end_model_line</span></span>(<span>line:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a ENDMDL (end model) line from a PDB file.</p>
<h2 id="columns-data-type-field-definition">Columns
Data
Type
Field
Definition</h2>
<p>1 - 6
Record name
"ENDMDL"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse_pdb_end_model_line(line: str):
    &#34;&#34;&#34;
    Parse a ENDMDL (end model) line from a PDB file.

    COLUMNS       DATA  TYPE     FIELD        DEFINITION
    ------------------------------------------------------------------
    1 - 6         Record name   &#34;ENDMDL&#34;

    &#34;&#34;&#34;
    pdb_end_model_dict = {
        &#34;record_name&#34;: &#34;ENDMDL&#34;
    }

    return pdb_end_model_dict</code></pre>
</details>
</dd>
<dt id="protkit.file_io.pdb_io.PDBIO.parse_pdb_entries"><code class="name flex">
<span>def <span class="ident">parse_pdb_entries</span></span>(<span>file_path:Â str, is_pqr_format:Â boolÂ =Â False)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse PDB file according to the spec provided at:
<a href="https://www.wwpdb.org/documentation/file-format-content/format33/sect9.html#ATOM">https://www.wwpdb.org/documentation/file-format-content/format33/sect9.html#ATOM</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse_pdb_entries(file_path: str, is_pqr_format: bool = False):
    &#34;&#34;&#34;
    Parse PDB file according to the spec provided at:
    https://www.wwpdb.org/documentation/file-format-content/format33/sect9.html#ATOM
    &#34;&#34;&#34;
    # Open the file and extract the individual lines.
    with open(file_path) as file:
        lines = file.read().split(&#34;\n&#34;)

    # Parse every line into dictionary information
    entries = []
    for line in lines:
        record_name = line[0:6].strip().upper()
        if record_name == &#34;ATOM&#34;:
            pdb_atom_dict = PDBIO.parse_pdb_atom_line(line)
            entries.append(pdb_atom_dict)
        elif record_name == &#34;HETATM&#34;:
            pdb_atom_dict = PDBIO.parse_pdb_atom_line(line, is_pqr_format=is_pqr_format)
            entries.append(pdb_atom_dict)
        elif record_name == &#34;TER&#34;:
            pdb_ter_dict = PDBIO.parse_pdb_ter_line(line)
            entries.append(pdb_ter_dict)
        elif record_name == &#34;MODEL&#34;:
            pdb_model_dict = PDBIO.parse_pdb_model_line(line)
            entries.append(pdb_model_dict)
        elif record_name == &#34;ENDMDL&#34;:
            pdb_end_model_dict = PDBIO.parse_pdb_end_model_line(line)
            entries.append(pdb_end_model_dict)
        elif record_name == &#34;SEQRES&#34;:
            pdb_seqres_dict = PDBIO.parse_pdb_seqres_line(line)
            entries.append(pdb_seqres_dict)
    return entries</code></pre>
</details>
</dd>
<dt id="protkit.file_io.pdb_io.PDBIO.parse_pdb_model_line"><code class="name flex">
<span>def <span class="ident">parse_pdb_model_line</span></span>(<span>line:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a MODEL (start model) line from a PDB file.</p>
<h2 id="columns-data-type-field-definition">Columns
Data
Type
Field
Definition</h2>
<p>1 -
6
Record name
"MODEL "
11 - 14
Integer
serial
Model serial number.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse_pdb_model_line(line: str):
    &#34;&#34;&#34;
    Parse a MODEL (start model) line from a PDB file.

    COLUMNS        DATA  TYPE    FIELD          DEFINITION
    ---------------------------------------------------------------------------------------
     1 -  6        Record name   &#34;MODEL &#34;
    11 - 14        Integer       serial         Model serial number.
    &#34;&#34;&#34;
    pdb_model_dict = {
        &#34;record_name&#34;: &#34;MODEL&#34;,
        &#34;serial&#34;: line[10:14]
    }

    return pdb_model_dict</code></pre>
</details>
</dd>
<dt id="protkit.file_io.pdb_io.PDBIO.parse_pdb_seqres_line"><code class="name flex">
<span>def <span class="ident">parse_pdb_seqres_line</span></span>(<span>line:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a SEQRES (sequence) line from a PDB file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse_pdb_seqres_line(line: str):
    &#34;&#34;&#34;
    Parse a SEQRES (sequence) line from a PDB file.
    &#34;&#34;&#34;
    pdb_seqres_dict = {
        &#34;record_name&#34;: &#34;SEQRES&#34;,
        &#34;chain_id&#34;: line[11],
        &#34;residues&#34;: line[19:].strip().split()
    }

    return pdb_seqres_dict</code></pre>
</details>
</dd>
<dt id="protkit.file_io.pdb_io.PDBIO.parse_pdb_ter_line"><code class="name flex">
<span>def <span class="ident">parse_pdb_ter_line</span></span>(<span>line:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a TER (chain termination) line from a PDB file.</p>
<h2 id="columns-data-type-field-definition">Columns
Data
Type
Field
Definition</h2>
<p>1 -
6
Record name
"TER
"
7 - 11
Integer
serial
Serial number.
18 - 20
Residue name
resName
Residue name.
22
Character
chainID
Chain identifier.
23 - 26
Integer
resSeq
Residue sequence number.
27
AChar
iCode
Insertion code.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse_pdb_ter_line(line: str):
    &#34;&#34;&#34;
    Parse a TER (chain termination) line from a PDB file.

    COLUMNS        DATA  TYPE    FIELD           DEFINITION
    -------------------------------------------------------------------------
     1 -  6        Record name   &#34;TER   &#34;
     7 - 11        Integer       serial          Serial number.
    18 - 20        Residue name  resName         Residue name.
    22             Character     chainID         Chain identifier.
    23 - 26        Integer       resSeq          Residue sequence number.
    27             AChar         iCode           Insertion code.

    &#34;&#34;&#34;
    if line == &#34;TER&#34;:
        pdb_ter_dict = {
            &#34;record_name&#34;: &#34;TER&#34;,
            &#34;serial&#34;: &#34;&#34;,
            &#34;res_name&#34;: &#34;&#34;,
            &#34;chain_id&#34;: &#34;&#34;,
            &#34;res_seq&#34;: &#34;&#34;,
            &#34;icode&#34;: &#34;&#34;
        }
    else:
        line = line.ljust(80)
        pdb_ter_dict = {
            &#34;record_name&#34;: &#34;TER&#34;,
            &#34;serial&#34;: line[6:11],
            &#34;res_name&#34;: line[17:21],
            &#34;chain_id&#34;: line[21],
            &#34;res_seq&#34;: line[22:26],
            &#34;icode&#34;: line[26]
        }
    return pdb_ter_dict</code></pre>
</details>
</dd>
<dt id="protkit.file_io.pdb_io.PDBIO.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>protein:Â <a title="protkit.structure.protein.Protein" href="../structure/protein.html#protkit.structure.protein.Protein">Protein</a>, file_path:Â str, is_pqr_format=False) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def save(protein: Protein,
         file_path: str,
         is_pqr_format=False) -&gt; None:
    text_entries = []
    num_seqres = 0
    num_atoms = 0
    num_hetatoms = 0
    num_ter = 0
    serial = 1

    for chain in protein.chains:
        for residue in chain.residues:
            for atom in residue.atoms:
                if not atom.is_hetero:
                    atom_entry = {
                        &#34;element&#34;: atom.element,
                        &#34;atom_name&#34;: atom.atom_type,
                        &#34;alt_loc&#34;: atom.get_attribute(&#34;pdb_alt_loc&#34;),
                        &#34;res_name&#34;: residue.residue_type,
                        &#34;chain_id&#34;: chain.chain_id,
                        &#34;res_seq&#34;: str(residue.sequence_no),
                        &#34;icode&#34;: residue.insertion_code,
                        &#34;x&#34;: atom.x,
                        &#34;y&#34;: atom.y,
                        &#34;z&#34;: atom.z,
                        &#34;occupancy&#34;: atom.get_attribute(&#34;occupancy&#34;),
                        # &#34;temp_factor&#34;: atom._pdb_temp_factor if atom._pdb_temp_factor is not None else 0.0,
                        &#34;temp_factor&#34;: atom.get_attribute(&#34;temp_factor&#34;),
                        &#34;charge&#34;: atom.get_attribute(&#34;assigned_charge&#34;)
                    }
                    text_entries.append(PDBIO.create_pdb_atom_line(atom_entry, serial))
                    serial += 1
                    num_atoms += 1

    # Bookkeeping records
    text_entries.append(PDBIO.create_pdb_master_line(num_atoms, num_hetatoms, num_ter, num_seqres=num_seqres))
    text_entries.append(&#34;END&#34;.ljust(80))

    with open(file_path, &#34;w&#34;) as file:
        file.write(&#34;\n&#34;.join(text_entries))</code></pre>
</details>
</dd>
<dt id="protkit.file_io.pdb_io.PDBIO.to_pdb_text"><code class="name flex">
<span>def <span class="ident">to_pdb_text</span></span>(<span>protein:Â <a title="protkit.structure.protein.Protein" href="../structure/protein.html#protkit.structure.protein.Protein">Protein</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def to_pdb_text(protein: Protein):
    text_entries = &#34;&#34;
    num_seqres = 0
    num_atoms = 0
    num_hetatoms = 0
    num_ter = 0
    serial = 1

    for chain in protein.chains:
        for residue in chain.residues:
            for atom in residue.atoms:
                if not atom.is_hetero:
                    atom_entry = {
                        &#34;element&#34;: atom.element,
                        &#34;atom_name&#34;: atom.atom_type,
                        &#34;alt_loc&#34;: atom.get_attribute(&#34;pdb_alt_loc&#34;),
                        &#34;res_name&#34;: residue.residue_type,
                        &#34;chain_id&#34;: chain.chain_id,
                        &#34;res_seq&#34;: str(residue.sequence_no),
                        &#34;icode&#34;: residue.insertion_code,
                        &#34;x&#34;: atom.x,
                        &#34;y&#34;: atom.y,
                        &#34;z&#34;: atom.z,
                        &#34;occupancy&#34;: atom.get_attribute(&#34;occupancy&#34;),
                        # &#34;temp_factor&#34;: atom._pdb_temp_factor if atom._pdb_temp_factor is not None else 0.0,
                        &#34;temp_factor&#34;: atom.get_attribute(&#34;temp_factor&#34;),
                        &#34;charge&#34;: atom.get_attribute(&#34;assigned_charge&#34;)
                    }
                    text_entries += PDBIO.create_pdb_atom_line(atom_entry, serial)
                    text_entries += &#34;\n&#34;
                    serial += 1
                    num_atoms += 1

    # Bookkeeping records
    text_entries += PDBIO.create_pdb_master_line(num_atoms, num_hetatoms, num_ter, num_seqres=num_seqres)
    text_entries += &#34;END&#34;.ljust(80)
    text_entries += &#34;\n&#34;

    return text_entries</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="protkit.file_io" href="index.html">protkit.file_io</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="protkit.file_io.pdb_io.PDBIO" href="#protkit.file_io.pdb_io.PDBIO">PDBIO</a></code></h4>
<ul class="">
<li><code><a title="protkit.file_io.pdb_io.PDBIO.create_pdb_atom_line" href="#protkit.file_io.pdb_io.PDBIO.create_pdb_atom_line">create_pdb_atom_line</a></code></li>
<li><code><a title="protkit.file_io.pdb_io.PDBIO.create_pdb_end_model_line" href="#protkit.file_io.pdb_io.PDBIO.create_pdb_end_model_line">create_pdb_end_model_line</a></code></li>
<li><code><a title="protkit.file_io.pdb_io.PDBIO.create_pdb_master_line" href="#protkit.file_io.pdb_io.PDBIO.create_pdb_master_line">create_pdb_master_line</a></code></li>
<li><code><a title="protkit.file_io.pdb_io.PDBIO.create_pdb_model_line" href="#protkit.file_io.pdb_io.PDBIO.create_pdb_model_line">create_pdb_model_line</a></code></li>
<li><code><a title="protkit.file_io.pdb_io.PDBIO.create_pdb_ter_line" href="#protkit.file_io.pdb_io.PDBIO.create_pdb_ter_line">create_pdb_ter_line</a></code></li>
<li><code><a title="protkit.file_io.pdb_io.PDBIO.create_seqres_line" href="#protkit.file_io.pdb_io.PDBIO.create_seqres_line">create_seqres_line</a></code></li>
<li><code><a title="protkit.file_io.pdb_io.PDBIO.from_pdb_text" href="#protkit.file_io.pdb_io.PDBIO.from_pdb_text">from_pdb_text</a></code></li>
<li><code><a title="protkit.file_io.pdb_io.PDBIO.load" href="#protkit.file_io.pdb_io.PDBIO.load">load</a></code></li>
<li><code><a title="protkit.file_io.pdb_io.PDBIO.parse_pdb_atom_line" href="#protkit.file_io.pdb_io.PDBIO.parse_pdb_atom_line">parse_pdb_atom_line</a></code></li>
<li><code><a title="protkit.file_io.pdb_io.PDBIO.parse_pdb_end_model_line" href="#protkit.file_io.pdb_io.PDBIO.parse_pdb_end_model_line">parse_pdb_end_model_line</a></code></li>
<li><code><a title="protkit.file_io.pdb_io.PDBIO.parse_pdb_entries" href="#protkit.file_io.pdb_io.PDBIO.parse_pdb_entries">parse_pdb_entries</a></code></li>
<li><code><a title="protkit.file_io.pdb_io.PDBIO.parse_pdb_model_line" href="#protkit.file_io.pdb_io.PDBIO.parse_pdb_model_line">parse_pdb_model_line</a></code></li>
<li><code><a title="protkit.file_io.pdb_io.PDBIO.parse_pdb_seqres_line" href="#protkit.file_io.pdb_io.PDBIO.parse_pdb_seqres_line">parse_pdb_seqres_line</a></code></li>
<li><code><a title="protkit.file_io.pdb_io.PDBIO.parse_pdb_ter_line" href="#protkit.file_io.pdb_io.PDBIO.parse_pdb_ter_line">parse_pdb_ter_line</a></code></li>
<li><code><a title="protkit.file_io.pdb_io.PDBIO.save" href="#protkit.file_io.pdb_io.PDBIO.save">save</a></code></li>
<li><code><a title="protkit.file_io.pdb_io.PDBIO.to_pdb_text" href="#protkit.file_io.pdb_io.PDBIO.to_pdb_text">to_pdb_text</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>